{"version":3,"sources":["../../../../../node_modules/abitype/src/version.ts","../../../../../node_modules/abitype/src/errors.ts","../../../../../node_modules/abitype/src/regex.ts","../../../../../node_modules/abitype/src/human-readable/runtime/signatures.ts","../../../../../node_modules/abitype/src/human-readable/errors/abiItem.ts","../../../../../node_modules/abitype/src/human-readable/errors/abiParameter.ts","../../../../../node_modules/abitype/src/human-readable/errors/signature.ts","../../../../../node_modules/abitype/src/human-readable/errors/struct.ts","../../../../../node_modules/abitype/src/human-readable/errors/splitParameters.ts","../../../../../node_modules/abitype/src/human-readable/runtime/cache.ts","../../../../../node_modules/abitype/src/human-readable/runtime/utils.ts","../../../../../node_modules/abitype/src/human-readable/runtime/structs.ts","../../../../../node_modules/abitype/src/human-readable/parseAbiParameters.ts","../../../../../node_modules/abitype/src/exports/index.ts","../../../../../node_modules/viem/utils/data/isHex.ts","../../../../../node_modules/viem/utils/data/size.ts","../../../../../node_modules/viem/errors/version.ts","../../../../../node_modules/viem/errors/base.ts","../../../../../node_modules/viem/errors/abi.ts","../../../../../node_modules/viem/errors/data.ts","../../../../../node_modules/viem/utils/data/pad.ts","../../../../../node_modules/viem/errors/encoding.ts","../../../../../node_modules/viem/utils/encoding/fromHex.ts","../../../../../node_modules/viem/utils/encoding/toHex.ts","../../../../../node_modules/viem/utils/encoding/toBytes.ts","../../../../../node_modules/viem/node_modules/@noble/hashes/src/_assert.ts","../../../../../node_modules/viem/node_modules/@noble/hashes/src/_u64.ts","../../../../../node_modules/viem/node_modules/@noble/hashes/src/utils.ts","../../../../../node_modules/viem/node_modules/@noble/hashes/src/sha3.ts","../../../../../node_modules/viem/utils/hash/keccak256.ts","../../../../../node_modules/viem/errors/address.ts","../../../../../node_modules/viem/utils/lru.ts","../../../../../node_modules/viem/utils/address/getAddress.ts","../../../../../node_modules/viem/utils/address/isAddress.ts","../../../../../node_modules/viem/utils/data/concat.ts","../../../../../node_modules/viem/utils/data/slice.ts","../../../../../node_modules/viem/utils/regex.ts","../../../../../node_modules/viem/utils/abi/encodeAbiParameters.ts","../../../../../node_modules/viem/utils/stringify.ts","../../../../../src/sdk/wallet/providers/walletClient.provider.ts","../../../../../node_modules/viem/index.ts","../../../../../node_modules/viem/utils/typedData.ts","../../../../../node_modules/viem/errors/typedData.ts","../../../../../node_modules/viem/utils/signature/hashTypedData.ts","../../../../../node_modules/viem/utils/signature/hashMessage.ts","../../../../../node_modules/viem/constants/strings.ts","../../../../../node_modules/viem/utils/signature/toPrefixedMessage.ts"],"sourcesContent":["export const version = '1.0.7'\n","import type { OneOf, Pretty } from './types.js'\nimport { version } from './version.js'\n\ntype BaseErrorArgs = Pretty<\n  {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\n>\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n\n  override name = 'AbiTypeError'\n\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n          ? args.cause.message\n          : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: abitype@${version}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { AbiStateMutability } from '../../abi.js'\nimport { execTyped } from '../../regex.js'\nimport type {\n  EventModifier,\n  FunctionModifier,\n  Modifier,\n} from '../types/signatures.js'\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex =\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isErrorSignature(signature: string) {\n  return errorSignatureRegex.test(signature)\n}\nexport function execErrorSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    errorSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmoq\nconst eventSignatureRegex =\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isEventSignature(signature: string) {\n  return eventSignatureRegex.test(signature)\n}\nexport function execEventSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    eventSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmot\nconst functionSignatureRegex =\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\nexport function isFunctionSignature(signature: string) {\n  return functionSignatureRegex.test(signature)\n}\nexport function execFunctionSignature(signature: string) {\n  return execTyped<{\n    name: string\n    parameters: string\n    stateMutability?: AbiStateMutability\n    returns?: string\n  }>(functionSignatureRegex, signature)\n}\n\n// https://regexr.com/7gmp3\nconst structSignatureRegex =\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\nexport function isStructSignature(signature: string) {\n  return structSignatureRegex.test(signature)\n}\nexport function execStructSignature(signature: string) {\n  return execTyped<{ name: string; properties: string }>(\n    structSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/78u01\nconst constructorSignatureRegex =\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isConstructorSignature(signature: string) {\n  return constructorSignatureRegex.test(signature)\n}\nexport function execConstructorSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(constructorSignatureRegex, signature)\n}\n\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex =\n  /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isFallbackSignature(signature: string) {\n  return fallbackSignatureRegex.test(signature)\n}\n\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\nexport function isReceiveSignature(signature: string) {\n  return receiveSignatureRegex.test(signature)\n}\n\nexport const modifiers = new Set<Modifier>([\n  'memory',\n  'indexed',\n  'storage',\n  'calldata',\n])\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\nexport const functionModifiers = new Set<FunctionModifier>([\n  'calldata',\n  'memory',\n  'storage',\n])\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidAbiItemError extends BaseError {\n  override name = 'InvalidAbiItemError'\n\n  constructor({ signature }: { signature: string | object }) {\n    super('Failed to parse ABI item.', {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: '/api/human#parseabiitem-1',\n    })\n  }\n}\n\nexport class UnknownTypeError extends BaseError {\n  override name = 'UnknownTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [\n        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n      ],\n    })\n  }\n}\n\nexport class UnknownSolidityTypeError extends BaseError {\n  override name = 'UnknownSolidityTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n    })\n  }\n}\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\nimport type { Modifier } from '../types/signatures.js'\n\nexport class InvalidAbiParameterError extends BaseError {\n  override name = 'InvalidAbiParameterError'\n\n  constructor({ param }: { param: string | object }) {\n    super('Failed to parse ABI parameter.', {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: '/api/human#parseabiparameter-1',\n    })\n  }\n}\n\nexport class InvalidAbiParametersError extends BaseError {\n  override name = 'InvalidAbiParametersError'\n\n  constructor({ params }: { params: string | object }) {\n    super('Failed to parse ABI parameters.', {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: '/api/human#parseabiparameters-1',\n    })\n  }\n}\n\nexport class InvalidParameterError extends BaseError {\n  override name = 'InvalidParameterError'\n\n  constructor({ param }: { param: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n    })\n  }\n}\n\nexport class SolidityProtectedKeywordError extends BaseError {\n  override name = 'SolidityProtectedKeywordError'\n\n  constructor({ param, name }: { param: string; name: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n      ],\n    })\n  }\n}\n\nexport class InvalidModifierError extends BaseError {\n  override name = 'InvalidModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidFunctionModifierError extends BaseError {\n  override name = 'InvalidFunctionModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidAbiTypeParameterError extends BaseError {\n  override name = 'InvalidAbiTypeParameterError'\n\n  constructor({\n    abiParameter,\n  }: {\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\n  }) {\n    super('Invalid ABI parameter.', {\n      details: JSON.stringify(abiParameter, null, 2),\n      metaMessages: ['ABI parameter type is invalid.'],\n    })\n  }\n}\n","import type { AbiItemType } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\n\nexport class InvalidSignatureError extends BaseError {\n  override name = 'InvalidSignatureError'\n\n  constructor({\n    signature,\n    type,\n  }: {\n    signature: string\n    type: AbiItemType | 'struct'\n  }) {\n    super(`Invalid ${type} signature.`, {\n      details: signature,\n    })\n  }\n}\n\nexport class UnknownSignatureError extends BaseError {\n  override name = 'UnknownSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Unknown signature.', {\n      details: signature,\n    })\n  }\n}\n\nexport class InvalidStructSignatureError extends BaseError {\n  override name = 'InvalidStructSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Invalid struct signature.', {\n      details: signature,\n      metaMessages: ['No properties exist.'],\n    })\n  }\n}\n","import { BaseError } from '../../errors.js'\n\nexport class CircularReferenceError extends BaseError {\n  override name = 'CircularReferenceError'\n\n  constructor({ type }: { type: string }) {\n    super('Circular reference detected.', {\n      metaMessages: [`Struct \"${type}\" is a circular reference.`],\n    })\n  }\n}\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidParenthesisError extends BaseError {\n  override name = 'InvalidParenthesisError'\n\n  constructor({ current, depth }: { current: string; depth: number }) {\n    super('Unbalanced parentheses.', {\n      metaMessages: [\n        `\"${current.trim()}\" has too many ${\n          depth > 0 ? 'opening' : 'closing'\n        } parentheses.`,\n      ],\n      details: `Depth \"${depth}\"`,\n    })\n  }\n}\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport type { StructLookup } from '../types/structs.js'\n\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(\n  param: string,\n  type?: AbiItemType | 'struct',\n  structs?: StructLookup,\n) {\n  let structKey = ''\n  if (structs)\n    for (const struct of Object.entries(structs)) {\n      if (!struct) continue\n      let propertyKey = ''\n      for (const property of struct[1]) {\n        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`\n      }\n      structKey += `(${struct[0]}{${propertyKey}})`\n    }\n  if (type) return `${type}:${param}${structKey}`\n  return param\n}\n\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map<\n  string,\n  AbiParameter & { indexed?: boolean }\n>([\n  // Unnamed\n  ['address', { type: 'address' }],\n  ['bool', { type: 'bool' }],\n  ['bytes', { type: 'bytes' }],\n  ['bytes32', { type: 'bytes32' }],\n  ['int', { type: 'int256' }],\n  ['int256', { type: 'int256' }],\n  ['string', { type: 'string' }],\n  ['uint', { type: 'uint256' }],\n  ['uint8', { type: 'uint8' }],\n  ['uint16', { type: 'uint16' }],\n  ['uint24', { type: 'uint24' }],\n  ['uint32', { type: 'uint32' }],\n  ['uint64', { type: 'uint64' }],\n  ['uint96', { type: 'uint96' }],\n  ['uint112', { type: 'uint112' }],\n  ['uint160', { type: 'uint160' }],\n  ['uint192', { type: 'uint192' }],\n  ['uint256', { type: 'uint256' }],\n\n  // Named\n  ['address owner', { type: 'address', name: 'owner' }],\n  ['address to', { type: 'address', name: 'to' }],\n  ['bool approved', { type: 'bool', name: 'approved' }],\n  ['bytes _data', { type: 'bytes', name: '_data' }],\n  ['bytes data', { type: 'bytes', name: 'data' }],\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\n  ['string name', { type: 'string', name: 'name' }],\n  ['string symbol', { type: 'string', name: 'symbol' }],\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint8 v', { type: 'uint8', name: 'v' }],\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint256 value', { type: 'uint256', name: 'value' }],\n\n  // Indexed\n  [\n    'event:address indexed from',\n    { type: 'address', name: 'from', indexed: true },\n  ],\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n  [\n    'event:uint indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n  [\n    'event:uint256 indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n])\n","import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n    const inputParams = splitParameters(match.parameters)\n    const inputs = []\n    const inputLength = inputParams.length\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n\n    const outputs = []\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns)\n      const outputLength = outputParams.length\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i]!, {\n            modifiers: functionModifiers,\n            structs,\n            type: 'function',\n          }),\n        )\n      }\n    }\n\n    return {\n      name: match.name,\n      type: 'function',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs,\n      outputs,\n    }\n  }\n\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, {\n          modifiers: eventModifiers,\n          structs,\n          type: 'event',\n        }),\n      )\n    }\n    return { name: match.name, type: 'event', inputs: abiParameters }\n  }\n\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'error' }),\n      )\n    }\n    return { name: match.name, type: 'error', inputs: abiParameters }\n  }\n\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature)\n    if (!match)\n      throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n      )\n    }\n    return {\n      type: 'constructor',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs: abiParameters,\n    }\n  }\n\n  if (isFallbackSignature(signature)) return { type: 'fallback' }\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(\n    param,\n    options?.type,\n    options?.structs,\n  )\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n","import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\n  structs: StructLookup,\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n","import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n> =\n  | (params extends string\n      ? params extends ''\n        ? never\n        : string extends params\n          ? readonly AbiParameter[]\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\n      : never)\n  | (params extends readonly string[]\n      ? string[] extends params\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<params> extends infer structs\n          ? {\n              [key in keyof params]: params[key] extends string\n                ? IsStructSignature<params[key]> extends true\n                  ? never\n                  : ParseAbiParameters_<\n                      SplitParameters<params[key]>,\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends readonly [...infer content]\n              ? content['length'] extends 0\n                ? never\n                : DeepFlatten<content>\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Flatten all members of {@link T}\n *\n * @param T - List of items to flatten\n * @param Acc - The accumulator used while recursing\n * @returns The flattened array\n *\n * @example\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\n * //   ^? type Result = ['a', 'b', 'c']\n */\ntype DeepFlatten<\n  T extends readonly unknown[],\n  Acc extends readonly unknown[] = readonly [],\n> = T extends readonly [infer head, ...infer tail]\n  ? tail extends undefined\n    ? never\n    : head extends readonly unknown[]\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\n      : DeepFlatten<tail, readonly [...Acc, head]>\n  : Acc\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<params> &\n    (\n      | (params extends string\n          ? params extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (params extends readonly string[]\n          ? params extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends params\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<params> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<params>\n}\n","export type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiInternalType,\n  AbiItemType,\n  AbiParameter,\n  AbiParameterKind,\n  AbiReceive,\n  AbiStateMutability,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArray,\n  SolidityArrayWithoutTuple,\n  SolidityArrayWithTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityFixedArrayRange,\n  SolidityFixedArraySizeLookup,\n  SolidityFunction,\n  SolidityInt,\n  SolidityString,\n  SolidityTuple,\n  TypedData,\n  TypedDataDomain,\n  TypedDataParameter,\n  TypedDataType,\n} from '../abi.js'\n\n// biome-ignore lint/performance/noBarrelFile: <explanation>\nexport { BaseError } from '../errors.js'\n\nexport type { Narrow } from '../narrow.js'\nexport { narrow } from '../narrow.js'\n\nexport type {\n  Register,\n  DefaultRegister,\n  ResolvedRegister,\n} from '../register.js'\n\nexport type {\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n  AbiTypeToPrimitiveType,\n  ExtractAbiError,\n  ExtractAbiErrorNames,\n  ExtractAbiErrors,\n  ExtractAbiEvent,\n  ExtractAbiEventNames,\n  ExtractAbiEvents,\n  ExtractAbiFunction,\n  ExtractAbiFunctionNames,\n  ExtractAbiFunctions,\n  IsAbi,\n  IsTypedData,\n  TypedDataToPrimitiveTypes,\n} from '../utils.js'\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Human-Readable\n\nexport {\n  formatAbi,\n  type FormatAbi,\n} from '../human-readable/formatAbi.js'\n\nexport {\n  formatAbiItem,\n  type FormatAbiItem,\n} from '../human-readable/formatAbiItem.js'\n\nexport {\n  formatAbiParameter,\n  type FormatAbiParameter,\n} from '../human-readable/formatAbiParameter.js'\n\nexport {\n  formatAbiParameters,\n  type FormatAbiParameters,\n} from '../human-readable/formatAbiParameters.js'\n\nexport { parseAbi, type ParseAbi } from '../human-readable/parseAbi.js'\n\nexport {\n  parseAbiItem,\n  type ParseAbiItem,\n} from '../human-readable/parseAbiItem.js'\n\nexport {\n  parseAbiParameter,\n  type ParseAbiParameter,\n} from '../human-readable/parseAbiParameter.js'\n\nexport {\n  parseAbiParameters,\n  type ParseAbiParameters,\n} from '../human-readable/parseAbiParameters.js'\n\nexport {\n  UnknownTypeError,\n  InvalidAbiItemError,\n  UnknownSolidityTypeError,\n} from '../human-readable/errors/abiItem.js'\n\nexport {\n  InvalidAbiTypeParameterError,\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  SolidityProtectedKeywordError,\n  InvalidParameterError,\n  InvalidAbiParametersError,\n  InvalidAbiParameterError,\n} from '../human-readable/errors/abiParameter.js'\n\nexport {\n  InvalidStructSignatureError,\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../human-readable/errors/signature.js'\n\nexport { InvalidParenthesisError } from '../human-readable/errors/splitParameters.js'\n\nexport { CircularReferenceError } from '../human-readable/errors/struct.js'\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsHexErrorType = ErrorType\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean | undefined } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\n\nexport type SizeErrorType = IsHexErrorType | ErrorType\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","export const version = '2.21.54'\n","import { version } from './version.js'\n\ntype ErrorConfig = {\n  getDocsUrl?: ((args: BaseErrorParameters) => string | undefined) | undefined\n  version?: string | undefined\n}\n\nlet errorConfig: ErrorConfig = {\n  getDocsUrl: ({\n    docsBaseUrl,\n    docsPath = '',\n    docsSlug,\n  }: BaseErrorParameters) =>\n    docsPath\n      ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${\n          docsSlug ? `#${docsSlug}` : ''\n        }`\n      : undefined,\n  version: `viem@${version}`,\n}\n\nexport function setErrorConfig(config: ErrorConfig) {\n  errorConfig = config\n}\n\ntype BaseErrorParameters = {\n  cause?: BaseError | Error | undefined\n  details?: string | undefined\n  docsBaseUrl?: string | undefined\n  docsPath?: string | undefined\n  docsSlug?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n  version: string\n\n  override name = 'BaseError'\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details = (() => {\n      if (args.cause instanceof BaseError) return args.cause.details\n      if (args.cause?.message) return args.cause.message\n      return args.details!\n    })()\n    const docsPath = (() => {\n      if (args.cause instanceof BaseError)\n        return args.cause.docsPath || args.docsPath\n      return args.docsPath\n    })()\n    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath })\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsUrl ? [`Docs: ${docsUrl}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),\n    ].join('\\n')\n\n    super(message, args.cause ? { cause: args.cause } : undefined)\n\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.name = args.name ?? this.name\n    this.shortMessage = shortMessage\n    this.version = version\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (\n    err &&\n    typeof err === 'object' &&\n    'cause' in err &&\n    err.cause !== undefined\n  )\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n      { name: 'SliceOffsetOutOfBoundsError' },\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n      { name: 'SizeExceedsPaddingSizeError' },\n    )\n  }\n}\n\nexport type InvalidBytesLengthErrorType = InvalidBytesLengthError & {\n  name: 'InvalidBytesLengthError'\n}\nexport class InvalidBytesLengthError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,\n      { name: 'InvalidBytesLengthError' },\n    )\n  }\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {\n  name: 'IntegerOutOfRangeError'\n}\nexport class IntegerOutOfRangeError extends BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n      { name: 'IntegerOutOfRangeError' },\n    )\n  }\n}\n\nexport type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {\n  name: 'InvalidBytesBooleanError'\n}\nexport class InvalidBytesBooleanError extends BaseError {\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n      {\n        name: 'InvalidBytesBooleanError',\n      },\n    )\n  }\n}\n\nexport type InvalidHexBooleanErrorType = InvalidHexBooleanError & {\n  name: 'InvalidHexBooleanError'\n}\nexport class InvalidHexBooleanError extends BaseError {\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n      { name: 'InvalidHexBooleanError' },\n    )\n  }\n}\n\nexport type InvalidHexValueErrorType = InvalidHexValueError & {\n  name: 'InvalidHexValueError'\n}\nexport class InvalidHexValueError extends BaseError {\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n      { name: 'InvalidHexValueError' },\n    )\n  }\n}\n\nexport type SizeOverflowErrorType = SizeOverflowError & {\n  name: 'SizeOverflowError'\n}\nexport class SizeOverflowError extends BaseError {\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n      { name: 'SizeOverflowError' },\n    )\n  }\n}\n","import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | to\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromHexReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'bigint'\n    ? bigint\n    : to extends 'number'\n      ? number\n      : to extends 'bytes'\n        ? ByteArray\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<to>): FromHexReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<to>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<to>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<to>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<to>\n  return hexToBytes(hex, opts) as FromHexReturnType<to>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","function anumber(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\n\nconst assert = {\n  number: anumber,\n  bytes: abytes,\n  hash: ahash,\n  exists: aexists,\n  output: aoutput,\n};\nexport default assert;\n","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n// TODO: re-check https://issues.chromium.org/issues/42212588\n\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { abytes, aexists, anumber, aoutput } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n  isLE,\n  byteSwap32,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    if (!isLE) byteSwap32(this.state32);\n    keccakP(this.state32, this.rounds);\n    if (!isLE) byteSwap32(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    aexists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n      name: 'InvalidAddressError',\n    })\n  }\n}\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n  const cacheKey = `${address}.${strict}`\n\n  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(cacheKey, result)\n  return result\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<value extends Hex | ByteArray> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<value extends Hex | ByteArray>(\n  values: readonly value[],\n): ConcatReturnType<value> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<value>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<value>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  type NumberToHexErrorType,\n  type StringToHexErrorType,\n  boolToHex,\n  numberToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import type { ErrorType } from '../errors/utils.js'\n\nexport type StringifyErrorType = ErrorType\n\nexport const stringify: typeof JSON.stringify = (value, replacer, space) =>\n  JSON.stringify(\n    value,\n    (key, value_) => {\n      const value = typeof value_ === 'bigint' ? value_.toString() : value_\n      return typeof replacer === 'function' ? replacer(key, value) : value\n    },\n    space,\n  )\n","import { Address, concat, encodeAbiParameters, Hash, hashMessage, hashTypedData, Hex, parseAbiParameters, toBytes, TransactionRequest, WalletClient } from 'viem';\nimport { MessagePayload, WalletProvider } from './interfaces.js';\n\nexport class WalletClientProvider implements WalletProvider {\n  readonly type = 'WalletClient';\n  readonly address: string;\n  readonly accountAddress: string;\n\n  readonly wallet: WalletClient;\n\n  constructor(walletClient: WalletClient) {\n    this.wallet = walletClient\n\n    const { address } = this.wallet.account;\n\n    this.address = address;\n  }\n\n  async signMessage(message: Hex, validatorAddress?: Address, factoryAddress?: Address, initCode?: Hex): Promise<string> {\n    const msg = toBytes(hashMessage({raw: toBytes(message)}));\n    const signature: Hex = await this.wallet.signMessage({\n      message: {raw: msg},\n      account: this.wallet.account\n    })\n    if (initCode !== '0x') {\n      const abiCoderResult = encodeAbiParameters(\n        parseAbiParameters('address, bytes, bytes'),\n        [factoryAddress, initCode, concat([validatorAddress, signature])]\n      )\n      return abiCoderResult + '6492649264926492649264926492649264926492649264926492649264926492'; //magicBytes\n    }\n    return concat([\n      validatorAddress,\n      signature\n    ]);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async signTypedData(msg: MessagePayload, validatorAddress?: Address, factoryAddress?: Address, initCode?: Hex): Promise<string> {\n    const typedDataEncoder = hashTypedData({domain: msg.domain, types: msg.types, primaryType: msg.primaryType, message: msg.message});\n    const signature = await this.wallet.signMessage({\n      message: {raw: toBytes(typedDataEncoder)},\n      account: this.wallet.account\n    });\n    if (initCode !== '0x') {\n      const abiCoderResult = encodeAbiParameters(\n        parseAbiParameters('address, bytes, bytes'),\n        [factoryAddress, initCode, concat([validatorAddress, signature])]\n      )\n      return abiCoderResult + '6492649264926492649264926492649264926492649264926492649264926492'; //magicBytes\n    }\n    return concat([\n      validatorAddress,\n      signature]\n    );\n  }\n\n  async eth_requestAccounts(address: string): Promise<string[]> {\n    return [address];\n  }\n\n  async eth_accounts(address: string): Promise<string[]> {\n    return [address];\n  }\n\n  async signUserOp(message: Hex): Promise<string> {\n    return this.wallet.signMessage({\n      message: { raw: message },\n      account: this.wallet.account\n    });\n  }\n\n  async eth_sendTransaction(transaction: TransactionRequest): Promise<Hash> {\n    return this.wallet.sendTransaction({\n      ...transaction,\n      account: this.wallet.account,\n      chain: this.wallet.chain,\n      kzg: undefined\n    });\n  }\n\n  async eth_signTransaction(transaction: TransactionRequest): Promise<string> {\n    return this.wallet.signTransaction({\n      ...transaction,\n      account: this.wallet.account,\n      chain: this.wallet.chain,\n      kzg: undefined\n    });\n  }\n}\n","// biome-ignore lint/performance/noBarrelFile: entrypoint module\nexport {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiEvent,\n  type AbiStateMutability,\n  type AbiParameterKind,\n  type AbiParameterToPrimitiveType,\n  type Address,\n  type Narrow,\n  type ParseAbi,\n  type ParseAbiItem,\n  type ParseAbiParameter,\n  type ParseAbiParameters,\n  type ResolvedRegister,\n  type TypedData,\n  type TypedDataDomain,\n  type TypedDataParameter,\n  CircularReferenceError,\n  InvalidAbiParameterError,\n  InvalidAbiParametersError,\n  InvalidAbiItemError,\n  InvalidAbiTypeParameterError,\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  InvalidParenthesisError,\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n  SolidityProtectedKeywordError,\n  UnknownTypeError,\n  UnknownSignatureError,\n  parseAbi,\n  parseAbiItem,\n  parseAbiParameter,\n  parseAbiParameters,\n} from 'abitype'\n\nexport {\n  getContract,\n  type GetContractErrorType,\n  type GetContractParameters,\n  type GetContractReturnType,\n} from './actions/getContract.js'\nexport {\n  type GetContractEventsErrorType,\n  type GetContractEventsParameters,\n  type GetContractEventsReturnType,\n} from './actions/public/getContractEvents.js'\nexport {\n  type GetEip712DomainErrorType,\n  type GetEip712DomainParameters,\n  type GetEip712DomainReturnType,\n} from './actions/public/getEip712Domain.js'\nexport {\n  type AddChainErrorType,\n  type AddChainParameters,\n} from './actions/wallet/addChain.js'\nexport {\n  type CallErrorType,\n  type CallParameters,\n  type CallReturnType,\n} from './actions/public/call.js'\nexport type {\n  CreateBlockFilterErrorType,\n  CreateBlockFilterReturnType,\n} from './actions/public/createBlockFilter.js'\nexport type {\n  CreateContractEventFilterErrorType,\n  CreateContractEventFilterParameters,\n  CreateContractEventFilterReturnType,\n} from './actions/public/createContractEventFilter.js'\nexport type {\n  CreateEventFilterErrorType,\n  CreateEventFilterParameters,\n  CreateEventFilterReturnType,\n} from './actions/public/createEventFilter.js'\nexport type {\n  CreatePendingTransactionFilterErrorType,\n  CreatePendingTransactionFilterReturnType,\n} from './actions/public/createPendingTransactionFilter.js'\nexport type {\n  DeployContractErrorType,\n  DeployContractParameters,\n  DeployContractReturnType,\n} from './actions/wallet/deployContract.js'\nexport type {\n  DropTransactionErrorType,\n  DropTransactionParameters,\n} from './actions/test/dropTransaction.js'\nexport type {\n  DumpStateErrorType,\n  DumpStateReturnType,\n} from './actions/test/dumpState.js'\nexport type {\n  GetAutomineErrorType,\n  GetAutomineReturnType,\n} from './actions/test/getAutomine.js'\nexport type {\n  EstimateContractGasErrorType,\n  EstimateContractGasParameters,\n  EstimateContractGasReturnType,\n} from './actions/public/estimateContractGas.js'\nexport type {\n  EstimateGasErrorType,\n  EstimateGasParameters,\n  EstimateGasReturnType,\n} from './actions/public/estimateGas.js'\nexport type {\n  EstimateFeesPerGasErrorType,\n  EstimateFeesPerGasParameters,\n  EstimateFeesPerGasReturnType,\n} from './actions/public/estimateFeesPerGas.js'\nexport type {\n  EstimateMaxPriorityFeePerGasErrorType,\n  EstimateMaxPriorityFeePerGasParameters,\n  EstimateMaxPriorityFeePerGasReturnType,\n} from './actions/public/estimateMaxPriorityFeePerGas.js'\nexport type {\n  GetAddressesErrorType,\n  GetAddressesReturnType,\n} from './actions/wallet/getAddresses.js'\nexport type {\n  GetBalanceErrorType,\n  GetBalanceParameters,\n  GetBalanceReturnType,\n} from './actions/public/getBalance.js'\nexport type {\n  GetBlobBaseFeeErrorType,\n  GetBlobBaseFeeReturnType,\n} from './actions/public/getBlobBaseFee.js'\nexport type {\n  GetBlockNumberErrorType,\n  GetBlockNumberParameters,\n  GetBlockNumberReturnType,\n} from './actions/public/getBlockNumber.js'\nexport type {\n  GetBlockErrorType,\n  GetBlockParameters,\n  GetBlockReturnType,\n} from './actions/public/getBlock.js'\nexport type {\n  GetBlockTransactionCountErrorType,\n  GetBlockTransactionCountParameters,\n  GetBlockTransactionCountReturnType,\n} from './actions/public/getBlockTransactionCount.js'\nexport type {\n  /** @deprecated Use `GetCodeErrorType` instead */\n  GetCodeErrorType as GetBytecodeErrorType,\n  /** @deprecated Use `GetCodeParameters` instead */\n  GetCodeParameters as GetBytecodeParameters,\n  /** @deprecated Use `GetCodeReturnType` instead  */\n  GetCodeReturnType as GetBytecodeReturnType,\n  GetCodeErrorType,\n  GetCodeParameters,\n  GetCodeReturnType,\n} from './actions/public/getCode.js'\nexport type {\n  GetChainIdErrorType,\n  GetChainIdReturnType,\n} from './actions/public/getChainId.js'\nexport type {\n  GetEnsAddressErrorType,\n  GetEnsAddressParameters,\n  GetEnsAddressReturnType,\n} from './actions/ens/getEnsAddress.js'\nexport type {\n  GetEnsAvatarErrorType,\n  GetEnsAvatarParameters,\n  GetEnsAvatarReturnType,\n} from './actions/ens/getEnsAvatar.js'\nexport type {\n  GetEnsNameErrorType,\n  GetEnsNameParameters,\n  GetEnsNameReturnType,\n} from './actions/ens/getEnsName.js'\nexport type {\n  GetEnsResolverErrorType,\n  GetEnsResolverParameters,\n  GetEnsResolverReturnType,\n} from './actions/ens/getEnsResolver.js'\nexport type {\n  GetEnsTextErrorType,\n  GetEnsTextParameters,\n  GetEnsTextReturnType,\n} from './actions/ens/getEnsText.js'\nexport type {\n  GetFeeHistoryErrorType,\n  GetFeeHistoryParameters,\n  GetFeeHistoryReturnType,\n} from './actions/public/getFeeHistory.js'\nexport type {\n  GetFilterChangesErrorType,\n  GetFilterChangesParameters,\n  GetFilterChangesReturnType,\n} from './actions/public/getFilterChanges.js'\nexport type {\n  GetFilterLogsErrorType,\n  GetFilterLogsParameters,\n  GetFilterLogsReturnType,\n} from './actions/public/getFilterLogs.js'\nexport type {\n  GetGasPriceErrorType,\n  GetGasPriceReturnType,\n} from './actions/public/getGasPrice.js'\nexport type {\n  GetLogsErrorType,\n  GetLogsParameters,\n  GetLogsReturnType,\n} from './actions/public/getLogs.js'\nexport type {\n  GetPermissionsErrorType,\n  GetPermissionsReturnType,\n} from './actions/wallet/getPermissions.js'\nexport type {\n  GetProofErrorType,\n  GetProofParameters,\n  GetProofReturnType,\n} from './actions/public/getProof.js'\nexport type {\n  GetStorageAtErrorType,\n  GetStorageAtParameters,\n  GetStorageAtReturnType,\n} from './actions/public/getStorageAt.js'\nexport type {\n  GetTransactionConfirmationsErrorType,\n  GetTransactionConfirmationsParameters,\n  GetTransactionConfirmationsReturnType,\n} from './actions/public/getTransactionConfirmations.js'\nexport type {\n  GetTransactionCountErrorType,\n  GetTransactionCountParameters,\n  GetTransactionCountReturnType,\n} from './actions/public/getTransactionCount.js'\nexport type {\n  GetTransactionErrorType,\n  GetTransactionParameters,\n  GetTransactionReturnType,\n} from './actions/public/getTransaction.js'\nexport type {\n  GetTransactionReceiptErrorType,\n  GetTransactionReceiptParameters,\n  GetTransactionReceiptReturnType,\n} from './actions/public/getTransactionReceipt.js'\nexport type {\n  ImpersonateAccountErrorType,\n  ImpersonateAccountParameters,\n} from './actions/test/impersonateAccount.js'\nexport type {\n  IncreaseTimeErrorType,\n  IncreaseTimeParameters,\n} from './actions/test/increaseTime.js'\nexport type {\n  LoadStateErrorType,\n  LoadStateParameters,\n  LoadStateReturnType,\n} from './actions/test/loadState.js'\nexport type { MineErrorType, MineParameters } from './actions/test/mine.js'\nexport type {\n  MulticallErrorType,\n  MulticallParameters,\n  MulticallReturnType,\n} from './actions/public/multicall.js'\nexport type { SnapshotErrorType } from './actions/test/snapshot.js'\nexport type {\n  OnBlock,\n  OnBlockParameter,\n  WatchBlocksErrorType,\n  WatchBlocksParameters,\n  WatchBlocksReturnType,\n} from './actions/public/watchBlocks.js'\nexport type {\n  OnBlockNumberFn,\n  OnBlockNumberParameter,\n  WatchBlockNumberErrorType,\n  WatchBlockNumberParameters,\n  WatchBlockNumberReturnType,\n} from './actions/public/watchBlockNumber.js'\nexport type {\n  WatchEventOnLogsFn,\n  WatchEventOnLogsParameter,\n  WatchEventErrorType,\n  WatchEventParameters,\n  WatchEventReturnType,\n} from './actions/public/watchEvent.js'\nexport type {\n  OnTransactionsFn,\n  OnTransactionsParameter,\n  WatchPendingTransactionsErrorType,\n  WatchPendingTransactionsParameters,\n  WatchPendingTransactionsReturnType,\n} from './actions/public/watchPendingTransactions.js'\nexport type {\n  ReadContractErrorType,\n  ReadContractParameters,\n  ReadContractReturnType,\n} from './actions/public/readContract.js'\nexport type {\n  ReplacementReason,\n  ReplacementReturnType,\n  WaitForTransactionReceiptErrorType,\n  WaitForTransactionReceiptParameters,\n  WaitForTransactionReceiptReturnType,\n} from './actions/public/waitForTransactionReceipt.js'\nexport type {\n  RequestAddressesErrorType,\n  RequestAddressesReturnType,\n} from './actions/wallet/requestAddresses.js'\nexport type {\n  RequestPermissionsErrorType,\n  RequestPermissionsReturnType,\n  RequestPermissionsParameters,\n} from './actions/wallet/requestPermissions.js'\nexport type {\n  GetTxpoolContentErrorType,\n  GetTxpoolContentReturnType,\n} from './actions/test/getTxpoolContent.js'\nexport type {\n  GetTxpoolStatusErrorType,\n  GetTxpoolStatusReturnType,\n} from './actions/test/getTxpoolStatus.js'\nexport type {\n  InspectTxpoolErrorType,\n  InspectTxpoolReturnType,\n} from './actions/test/inspectTxpool.js'\nexport type { RemoveBlockTimestampIntervalErrorType } from './actions/test/removeBlockTimestampInterval.js'\nexport type { ResetErrorType, ResetParameters } from './actions/test/reset.js'\nexport type {\n  RevertErrorType,\n  RevertParameters,\n} from './actions/test/revert.js'\nexport type {\n  SendRawTransactionErrorType,\n  SendRawTransactionParameters,\n  SendRawTransactionReturnType,\n} from './actions/wallet/sendRawTransaction.js'\nexport type {\n  SendTransactionErrorType,\n  SendTransactionParameters,\n  SendTransactionRequest,\n  SendTransactionReturnType,\n} from './actions/wallet/sendTransaction.js'\nexport type {\n  SignTransactionErrorType,\n  SignTransactionParameters,\n  SignTransactionReturnType,\n} from './actions/wallet/signTransaction.js'\nexport type {\n  PrepareTransactionRequestErrorType,\n  PrepareTransactionRequestParameters,\n  PrepareTransactionRequestParameterType,\n  PrepareTransactionRequestRequest,\n  PrepareTransactionRequestReturnType,\n} from './actions/wallet/prepareTransactionRequest.js'\nexport type {\n  SendUnsignedTransactionErrorType,\n  SendUnsignedTransactionParameters,\n  SendUnsignedTransactionReturnType,\n} from './actions/test/sendUnsignedTransaction.js'\nexport type { SetAutomineErrorType } from './actions/test/setAutomine.js'\nexport type {\n  SetBalanceErrorType,\n  SetBalanceParameters,\n} from './actions/test/setBalance.js'\nexport type {\n  SetBlockGasLimitErrorType,\n  SetBlockGasLimitParameters,\n} from './actions/test/setBlockGasLimit.js'\nexport type {\n  SetBlockTimestampIntervalErrorType,\n  SetBlockTimestampIntervalParameters,\n} from './actions/test/setBlockTimestampInterval.js'\nexport type {\n  SetCodeErrorType,\n  SetCodeParameters,\n} from './actions/test/setCode.js'\nexport type {\n  SetCoinbaseErrorType,\n  SetCoinbaseParameters,\n} from './actions/test/setCoinbase.js'\nexport type {\n  SetIntervalMiningErrorType,\n  SetIntervalMiningParameters,\n} from './actions/test/setIntervalMining.js'\nexport type { SetLoggingEnabledErrorType } from './actions/test/setLoggingEnabled.js'\nexport type {\n  SetMinGasPriceErrorType,\n  SetMinGasPriceParameters,\n} from './actions/test/setMinGasPrice.js'\nexport type {\n  SetNextBlockBaseFeePerGasErrorType,\n  SetNextBlockBaseFeePerGasParameters,\n} from './actions/test/setNextBlockBaseFeePerGas.js'\nexport type {\n  SetNextBlockTimestampErrorType,\n  SetNextBlockTimestampParameters,\n} from './actions/test/setNextBlockTimestamp.js'\nexport type {\n  SetNonceErrorType,\n  SetNonceParameters,\n} from './actions/test/setNonce.js'\nexport type { SetRpcUrlErrorType } from './actions/test/setRpcUrl.js'\nexport type {\n  SetStorageAtErrorType,\n  SetStorageAtParameters,\n} from './actions/test/setStorageAt.js'\nexport type {\n  SignMessageErrorType,\n  SignMessageParameters,\n  SignMessageReturnType,\n} from './actions/wallet/signMessage.js'\nexport type {\n  SignTypedDataErrorType,\n  SignTypedDataParameters,\n  SignTypedDataReturnType,\n} from './actions/wallet/signTypedData.js'\nexport type {\n  SimulateContractErrorType,\n  SimulateContractParameters,\n  SimulateContractReturnType,\n} from './actions/public/simulateContract.js'\nexport type {\n  StopImpersonatingAccountErrorType,\n  StopImpersonatingAccountParameters,\n} from './actions/test/stopImpersonatingAccount.js'\nexport type {\n  SwitchChainErrorType,\n  SwitchChainParameters,\n} from './actions/wallet/switchChain.js'\nexport type {\n  UninstallFilterErrorType,\n  UninstallFilterParameters,\n  UninstallFilterReturnType,\n} from './actions/public/uninstallFilter.js'\nexport type {\n  WatchAssetErrorType,\n  WatchAssetParameters,\n  WatchAssetReturnType,\n} from './actions/wallet/watchAsset.js'\nexport type {\n  VerifyHashErrorType as VerifyHashActionErrorType,\n  VerifyHashParameters as VerifyHashActionParameters,\n  VerifyHashReturnType as VerifyHashActionReturnType,\n} from './actions/public/verifyHash.js'\nexport type {\n  VerifyTypedDataErrorType as VerifyTypedDataActionErrorType,\n  VerifyTypedDataParameters as VerifyTypedDataActionParameters,\n  VerifyTypedDataReturnType as VerifyTypedDataActionReturnType,\n} from './actions/public/verifyTypedData.js'\nexport type {\n  VerifyMessageErrorType as VerifyMessageActionErrorType,\n  VerifyMessageParameters as VerifyMessageActionParameters,\n  VerifyMessageReturnType as VerifyMessageActionReturnType,\n} from './actions/public/verifyMessage.js'\nexport type {\n  WatchContractEventOnLogsFn,\n  WatchContractEventOnLogsParameter,\n  WatchContractEventErrorType,\n  WatchContractEventParameters,\n  WatchContractEventReturnType,\n} from './actions/public/watchContractEvent.js'\nexport type {\n  WriteContractErrorType,\n  WriteContractParameters,\n  WriteContractReturnType,\n} from './actions/wallet/writeContract.js'\nexport type {\n  Chain,\n  ChainConfig,\n  ChainContract,\n  ChainEstimateFeesPerGasFn,\n  ChainFees,\n  ChainFeesFnParameters,\n  ChainFormatter,\n  ChainEstimateFeesPerGasFnParameters,\n  ChainMaxPriorityFeePerGasFn,\n  DeriveChain,\n  GetChainParameter,\n  ChainFormatters,\n  ChainSerializers,\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterParameters,\n  ExtractChainFormatterReturnType,\n} from './types/chain.js'\nexport type { GetTransactionRequestKzgParameter, Kzg } from './types/kzg.js'\nexport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  type MulticallBatchOptions,\n  createClient,\n  rpcSchema,\n} from './clients/createClient.js'\nexport {\n  type CustomTransport,\n  type CustomTransportConfig,\n  type CustomTransportErrorType,\n  custom,\n} from './clients/transports/custom.js'\nexport {\n  type FallbackTransport,\n  type FallbackTransportConfig,\n  type FallbackTransportErrorType,\n  fallback,\n} from './clients/transports/fallback.js'\nexport {\n  type HttpTransport,\n  type HttpTransportConfig,\n  type HttpTransportErrorType,\n  http,\n} from './clients/transports/http.js'\nexport {\n  type PublicClient,\n  type PublicClientConfig,\n  type CreatePublicClientErrorType,\n  createPublicClient,\n} from './clients/createPublicClient.js'\nexport {\n  type TestClient,\n  type TestClientConfig,\n  type CreateTestClientErrorType,\n  createTestClient,\n} from './clients/createTestClient.js'\nexport {\n  type PublicActions,\n  publicActions,\n} from './clients/decorators/public.js'\nexport {\n  type TestActions,\n  testActions,\n} from './clients/decorators/test.js'\nexport {\n  type WalletActions,\n  walletActions,\n} from './clients/decorators/wallet.js'\nexport {\n  type Transport,\n  type TransportConfig,\n  type CreateTransportErrorType,\n  createTransport,\n} from './clients/transports/createTransport.js'\nexport {\n  type WalletClient,\n  type WalletClientConfig,\n  type CreateWalletClientErrorType,\n  createWalletClient,\n} from './clients/createWalletClient.js'\nexport {\n  type WebSocketTransport,\n  type WebSocketTransportConfig,\n  type WebSocketTransportErrorType,\n  webSocket,\n} from './clients/transports/webSocket.js'\nexport {\n  multicall3Abi,\n  erc20Abi,\n  erc20Abi_bytes32,\n  erc721Abi,\n  erc4626Abi,\n  universalSignatureValidatorAbi,\n} from './constants/abis.js'\nexport { zeroAddress } from './constants/address.js'\nexport {\n  deploylessCallViaBytecodeBytecode,\n  deploylessCallViaFactoryBytecode,\n  universalSignatureValidatorByteCode,\n} from './constants/contracts.js'\nexport { etherUnits, gweiUnits, weiUnits } from './constants/unit.js'\nexport {\n  maxInt8,\n  maxInt16,\n  maxInt24,\n  maxInt32,\n  maxInt40,\n  maxInt48,\n  maxInt56,\n  maxInt64,\n  maxInt72,\n  maxInt80,\n  maxInt88,\n  maxInt96,\n  maxInt104,\n  maxInt112,\n  maxInt120,\n  maxInt128,\n  maxInt136,\n  maxInt144,\n  maxInt152,\n  maxInt160,\n  maxInt168,\n  maxInt176,\n  maxInt184,\n  maxInt192,\n  maxInt200,\n  maxInt208,\n  maxInt216,\n  maxInt224,\n  maxInt232,\n  maxInt240,\n  maxInt248,\n  maxInt256,\n  maxUint8,\n  maxUint16,\n  maxUint24,\n  maxUint32,\n  maxUint40,\n  maxUint48,\n  maxUint56,\n  maxUint64,\n  maxUint72,\n  maxUint80,\n  maxUint88,\n  maxUint96,\n  maxUint104,\n  maxUint112,\n  maxUint120,\n  maxUint128,\n  maxUint136,\n  maxUint144,\n  maxUint152,\n  maxUint160,\n  maxUint168,\n  maxUint176,\n  maxUint184,\n  maxUint192,\n  maxUint200,\n  maxUint208,\n  maxUint216,\n  maxUint224,\n  maxUint232,\n  maxUint240,\n  maxUint248,\n  maxUint256,\n  minInt8,\n  minInt16,\n  minInt24,\n  minInt32,\n  minInt40,\n  minInt48,\n  minInt56,\n  minInt64,\n  minInt72,\n  minInt80,\n  minInt88,\n  minInt96,\n  minInt104,\n  minInt112,\n  minInt120,\n  minInt128,\n  minInt136,\n  minInt144,\n  minInt152,\n  minInt160,\n  minInt168,\n  minInt176,\n  minInt184,\n  minInt192,\n  minInt200,\n  minInt208,\n  minInt216,\n  minInt224,\n  minInt232,\n  minInt240,\n  minInt248,\n  minInt256,\n} from './constants/number.js'\nexport { zeroHash } from './constants/bytes.js'\nexport { presignMessagePrefix } from './constants/strings.js'\nexport {\n  AbiConstructorNotFoundError,\n  type AbiConstructorNotFoundErrorType,\n  AbiConstructorParamsNotFoundError,\n  type AbiConstructorParamsNotFoundErrorType,\n  AbiDecodingDataSizeInvalidError,\n  type AbiDecodingDataSizeInvalidErrorType,\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiErrorInputsNotFoundError,\n  type AbiErrorInputsNotFoundErrorType,\n  AbiErrorNotFoundError,\n  type AbiErrorNotFoundErrorType,\n  AbiErrorSignatureNotFoundError,\n  type AbiErrorSignatureNotFoundErrorType,\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n  AbiFunctionOutputsNotFoundError,\n  type AbiFunctionOutputsNotFoundErrorType,\n  AbiFunctionSignatureNotFoundError,\n  type AbiFunctionSignatureNotFoundErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n  UnsupportedPackedAbiType,\n  type UnsupportedPackedAbiTypeErrorType,\n} from './errors/abi.js'\nexport { BaseError, type BaseErrorType, setErrorConfig } from './errors/base.js'\nexport {\n  BlockNotFoundError,\n  type BlockNotFoundErrorType,\n} from './errors/block.js'\nexport {\n  CallExecutionError,\n  type CallExecutionErrorType,\n  ContractFunctionExecutionError,\n  type ContractFunctionExecutionErrorType,\n  ContractFunctionRevertedError,\n  type ContractFunctionRevertedErrorType,\n  ContractFunctionZeroDataError,\n  type ContractFunctionZeroDataErrorType,\n  RawContractError,\n  type RawContractErrorType,\n  CounterfactualDeploymentFailedError,\n  type CounterfactualDeploymentFailedErrorType,\n} from './errors/contract.js'\nexport {\n  BaseFeeScalarError,\n  type BaseFeeScalarErrorType,\n  Eip1559FeesNotSupportedError,\n  type Eip1559FeesNotSupportedErrorType,\n  MaxFeePerGasTooLowError,\n  type MaxFeePerGasTooLowErrorType,\n} from './errors/fee.js'\nexport {\n  ChainDisconnectedError,\n  type ChainDisconnectedErrorType,\n  InternalRpcError,\n  type InternalRpcErrorType,\n  InvalidInputRpcError,\n  type InvalidInputRpcErrorType,\n  InvalidParamsRpcError,\n  type InvalidParamsRpcErrorType,\n  InvalidRequestRpcError,\n  type InvalidRequestRpcErrorType,\n  JsonRpcVersionUnsupportedError,\n  type JsonRpcVersionUnsupportedErrorType,\n  LimitExceededRpcError,\n  type LimitExceededRpcErrorType,\n  MethodNotFoundRpcError,\n  type MethodNotFoundRpcErrorType,\n  MethodNotSupportedRpcError,\n  type MethodNotSupportedRpcErrorType,\n  ParseRpcError,\n  type ParseRpcErrorType,\n  ProviderDisconnectedError,\n  type ProviderDisconnectedErrorType,\n  ProviderRpcError,\n  type ProviderRpcErrorCode,\n  type ProviderRpcErrorType,\n  ResourceNotFoundRpcError,\n  type ResourceNotFoundRpcErrorType,\n  ResourceUnavailableRpcError,\n  type ResourceUnavailableRpcErrorType,\n  RpcError,\n  type RpcErrorType,\n  type RpcErrorCode,\n  SwitchChainError,\n  TransactionRejectedRpcError,\n  type TransactionRejectedRpcErrorType,\n  UnauthorizedProviderError,\n  type UnauthorizedProviderErrorType,\n  UnknownRpcError,\n  type UnknownRpcErrorType,\n  UnsupportedProviderMethodError,\n  type UnsupportedProviderMethodErrorType,\n  UserRejectedRequestError,\n  type UserRejectedRequestErrorType,\n} from './errors/rpc.js'\nexport {\n  ChainDoesNotSupportContract,\n  type ChainDoesNotSupportContractErrorType,\n  ChainMismatchError,\n  type ChainMismatchErrorType,\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n  ClientChainNotConfiguredError,\n  type ClientChainNotConfiguredErrorType,\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from './errors/chain.js'\nexport {\n  InvalidBytesBooleanError,\n  type InvalidBytesBooleanErrorType,\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  InvalidHexValueError,\n  type InvalidHexValueErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from './errors/encoding.js'\nexport {\n  type EnsAvatarInvalidMetadataError,\n  EnsAvatarUriResolutionError,\n  type EnsAvatarInvalidMetadataErrorType,\n  EnsAvatarInvalidNftUriError,\n  type EnsAvatarInvalidNftUriErrorType,\n  EnsAvatarUnsupportedNamespaceError,\n  type EnsAvatarUnsupportedNamespaceErrorType,\n  type EnsAvatarUriResolutionErrorType,\n} from './errors/ens.js'\nexport {\n  type InvalidDecimalNumberErrorType,\n  InvalidDecimalNumberError,\n} from './errors/unit.js'\nexport {\n  EstimateGasExecutionError,\n  type EstimateGasExecutionErrorType,\n} from './errors/estimateGas.js'\nexport {\n  ExecutionRevertedError,\n  type ExecutionRevertedErrorType,\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  FeeCapTooLowError,\n  type FeeCapTooLowErrorType,\n  InsufficientFundsError,\n  type InsufficientFundsErrorType,\n  IntrinsicGasTooHighError,\n  type IntrinsicGasTooHighErrorType,\n  IntrinsicGasTooLowError,\n  type IntrinsicGasTooLowErrorType,\n  NonceMaxValueError,\n  type NonceMaxValueErrorType,\n  NonceTooHighError,\n  type NonceTooHighErrorType,\n  NonceTooLowError,\n  type NonceTooLowErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n  TransactionTypeNotSupportedError,\n  type TransactionTypeNotSupportedErrorType,\n  UnknownNodeError,\n  type UnknownNodeErrorType,\n} from './errors/node.js'\nexport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from './errors/log.js'\nexport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n  RpcRequestError,\n  type RpcRequestErrorType,\n  TimeoutError,\n  type TimeoutErrorType,\n  SocketClosedError,\n  type SocketClosedErrorType,\n  WebSocketRequestError,\n  type WebSocketRequestErrorType,\n} from './errors/request.js'\nexport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from './errors/address.js'\nexport {\n  FeeConflictError,\n  type FeeConflictErrorType,\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n  InvalidSerializedTransactionError,\n  type InvalidSerializedTransactionErrorType,\n  InvalidSerializedTransactionTypeError,\n  type InvalidSerializedTransactionTypeErrorType,\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n  TransactionExecutionError,\n  type TransactionExecutionErrorType,\n  TransactionNotFoundError,\n  type TransactionNotFoundErrorType,\n  TransactionReceiptNotFoundError,\n  type TransactionReceiptNotFoundErrorType,\n  WaitForTransactionReceiptTimeoutError,\n  type WaitForTransactionReceiptTimeoutErrorType,\n} from './errors/transaction.js'\nexport {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from './errors/data.js'\nexport {\n  UrlRequiredError,\n  type UrlRequiredErrorType,\n} from './errors/transport.js'\nexport {\n  AccountStateConflictError,\n  type AccountStateConflictErrorType,\n  StateAssignmentConflictError,\n  type StateAssignmentConflictErrorType,\n} from './errors/stateOverride.js'\nexport {\n  InvalidDomainError,\n  type InvalidDomainErrorType,\n  InvalidPrimaryTypeError,\n  type InvalidPrimaryTypeErrorType,\n  InvalidStructTypeError,\n  type InvalidStructTypeErrorType,\n} from './errors/typedData.js'\nexport type {\n  AbiEventParameterToPrimitiveType,\n  AbiEventParametersToPrimitiveTypes,\n  AbiEventTopicToPrimitiveType,\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ContractConstructorArgs,\n  ContractEventArgsFromTopics,\n  EventDefinition,\n  ExtractAbiFunctionForArgs,\n  ExtractAbiItem,\n  ExtractAbiItemForArgs,\n  ExtractAbiItemNames,\n  ContractErrorArgs,\n  ContractErrorName,\n  ContractEventArgs,\n  ContractEventName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n  ContractFunctionArgs,\n  ContractFunctionName,\n  GetEventArgs,\n  GetValue,\n  LogTopicType,\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n  UnionWiden,\n  Widen,\n} from './types/contract.js'\nexport type {\n  AccessList,\n  Transaction,\n  TransactionBase,\n  TransactionEIP1559,\n  TransactionEIP2930,\n  TransactionEIP4844,\n  TransactionEIP7702,\n  TransactionLegacy,\n  TransactionReceipt,\n  TransactionRequest,\n  TransactionRequestBase,\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestEIP7702,\n  TransactionRequestGeneric,\n  TransactionRequestLegacy,\n  TransactionSerializable,\n  TransactionSerializableBase,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedEIP7702,\n  TransactionSerializedGeneric,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from './types/transaction.js'\nexport type {\n  Assign,\n  Branded,\n  Evaluate,\n  IsNarrowable,\n  IsUndefined,\n  IsUnion,\n  LooseOmit,\n  MaybePartial,\n  MaybePromise,\n  MaybeRequired,\n  Mutable,\n  NoInfer,\n  NoUndefined,\n  Omit,\n  Or,\n  PartialBy,\n  RequiredBy,\n  Some,\n  UnionEvaluate,\n  UnionLooseOmit,\n  ValueOf,\n  Prettify,\n  ExactPartial,\n  ExactRequired,\n  IsNever,\n  OneOf,\n  UnionOmit,\n  UnionPartialBy,\n  UnionPick,\n  UnionRequiredBy,\n  UnionToTuple,\n} from './types/utils.js'\nexport type {\n  Account,\n  AccountSource,\n  CustomSource,\n  HDAccount,\n  HDOptions,\n  JsonRpcAccount,\n  LocalAccount,\n  PrivateKeyAccount,\n} from './accounts/types.js'\nexport type { AssetGateway, AssetGatewayUrls } from './types/ens.js'\nexport type {\n  Block,\n  BlockIdentifier,\n  BlockNumber,\n  BlockTag,\n  Uncle,\n} from './types/block.js'\nexport type {\n  ByteArray,\n  Hash,\n  Hex,\n  LogTopic,\n  Signature,\n  CompactSignature,\n  SignableMessage,\n} from './types/misc.js'\nexport type {\n  AddEthereumChainParameter,\n  BundlerRpcSchema,\n  DebugBundlerRpcSchema,\n  EIP1193EventMap,\n  EIP1193Events,\n  EIP1193Parameters,\n  EIP1193Provider,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  ProviderRpcErrorType as EIP1193ProviderRpcErrorType,\n  ProviderConnectInfo,\n  ProviderMessage,\n  PublicRpcSchema,\n  PaymasterRpcSchema,\n  NetworkSync,\n  RpcSchema,\n  RpcSchemaOverride,\n  TestRpcSchema,\n  WalletCapabilities,\n  WalletCapabilitiesRecord,\n  WalletCallReceipt,\n  WalletGetCallsStatusReturnType,\n  WalletGrantPermissionsParameters,\n  WalletGrantPermissionsReturnType,\n  WalletSendCallsParameters,\n  WalletPermissionCaveat,\n  WalletPermission,\n  WalletRpcSchema,\n  WatchAssetParams,\n} from './types/eip1193.js'\nexport { ProviderRpcError as EIP1193ProviderRpcError } from './types/eip1193.js'\nexport type { BlobSidecar, BlobSidecars } from './types/eip4844.js'\nexport type {\n  FeeHistory,\n  FeeValues,\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n  FeeValuesType,\n} from './types/fee.js'\nexport type { Filter, FilterType } from './types/filter.js'\nexport type { TypedDataDefinition } from './types/typedData.js'\nexport type { GetTransportConfig, GetPollOptions } from './types/transport.js'\nexport type { Log } from './types/log.js'\nexport type {\n  MulticallContracts,\n  MulticallResponse,\n  MulticallResults,\n} from './types/multicall.js'\nexport type {\n  ParseAccount,\n  DeriveAccount,\n  HDKey,\n} from './types/account.js'\nexport type {\n  Index,\n  Quantity,\n  RpcBlock,\n  RpcBlockIdentifier,\n  RpcBlockNumber,\n  RpcFeeHistory,\n  RpcFeeValues,\n  RpcLog,\n  RpcTransaction,\n  RpcTransactionReceipt,\n  RpcTransactionRequest,\n  RpcUncle,\n  Status,\n  RpcProof,\n  RpcAccountStateOverride,\n  RpcStateOverride,\n  RpcStateMapping,\n} from './types/rpc.js'\nexport type { Withdrawal } from './types/withdrawal.js'\nexport type {\n  StateMapping,\n  StateOverride,\n} from './types/stateOverride.js'\nexport { labelhash, type LabelhashErrorType } from './utils/ens/labelhash.js'\nexport { namehash, type NamehashErrorType } from './utils/ens/namehash.js'\nexport {\n  type FormattedBlock,\n  defineBlock,\n  type DefineBlockErrorType,\n  formatBlock,\n  type FormatBlockErrorType,\n} from './utils/formatters/block.js'\nexport { formatLog, type FormatLogErrorType } from './utils/formatters/log.js'\nexport {\n  type DecodeAbiParametersErrorType,\n  type DecodeAbiParametersReturnType,\n  decodeAbiParameters,\n} from './utils/abi/decodeAbiParameters.js'\nexport {\n  type DecodeDeployDataErrorType,\n  type DecodeDeployDataParameters,\n  type DecodeDeployDataReturnType,\n  decodeDeployData,\n} from './utils/abi/decodeDeployData.js'\nexport {\n  type DecodeErrorResultErrorType,\n  type DecodeErrorResultParameters,\n  type DecodeErrorResultReturnType,\n  decodeErrorResult,\n} from './utils/abi/decodeErrorResult.js'\nexport {\n  type DecodeEventLogErrorType,\n  type DecodeEventLogParameters,\n  type DecodeEventLogReturnType,\n  decodeEventLog,\n} from './utils/abi/decodeEventLog.js'\nexport {\n  type DecodeFunctionDataErrorType,\n  type DecodeFunctionDataParameters,\n  type DecodeFunctionDataReturnType,\n  decodeFunctionData,\n} from './utils/abi/decodeFunctionData.js'\nexport {\n  type DecodeFunctionResultErrorType,\n  type DecodeFunctionResultParameters,\n  type DecodeFunctionResultReturnType,\n  decodeFunctionResult,\n} from './utils/abi/decodeFunctionResult.js'\nexport {\n  type EncodeAbiParametersErrorType,\n  type EncodeAbiParametersReturnType,\n  encodeAbiParameters,\n} from './utils/abi/encodeAbiParameters.js'\nexport {\n  type EncodeDeployDataErrorType,\n  type EncodeDeployDataParameters,\n  type EncodeDeployDataReturnType,\n  encodeDeployData,\n} from './utils/abi/encodeDeployData.js'\nexport {\n  type EncodeErrorResultErrorType,\n  type EncodeErrorResultParameters,\n  type EncodeErrorResultReturnType,\n  encodeErrorResult,\n} from './utils/abi/encodeErrorResult.js'\nexport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  type EncodeEventTopicsReturnType,\n  encodeEventTopics,\n} from './utils/abi/encodeEventTopics.js'\nexport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  type EncodeFunctionDataReturnType,\n  encodeFunctionData,\n} from './utils/abi/encodeFunctionData.js'\nexport {\n  type PrepareEncodeFunctionDataErrorType,\n  type PrepareEncodeFunctionDataParameters,\n  type PrepareEncodeFunctionDataReturnType,\n  prepareEncodeFunctionData,\n} from './utils/abi/prepareEncodeFunctionData.js'\nexport {\n  type EncodeFunctionResultErrorType,\n  type EncodeFunctionResultParameters,\n  type EncodeFunctionResultReturnType,\n  encodeFunctionResult,\n} from './utils/abi/encodeFunctionResult.js'\nexport {\n  type ParseEventLogsErrorType,\n  type ParseEventLogsParameters,\n  type ParseEventLogsReturnType,\n  parseEventLogs,\n} from './utils/abi/parseEventLogs.js'\nexport {\n  type FormattedTransaction,\n  defineTransaction,\n  type DefineTransactionErrorType,\n  formatTransaction,\n  type FormatTransactionErrorType,\n  transactionType,\n} from './utils/formatters/transaction.js'\nexport {\n  type FormattedTransactionReceipt,\n  defineTransactionReceipt,\n  type DefineTransactionReceiptErrorType,\n  formatTransactionReceipt,\n  type FormatTransactionReceiptErrorType,\n} from './utils/formatters/transactionReceipt.js'\nexport {\n  type FormattedTransactionRequest,\n  defineTransactionRequest,\n  type DefineTransactionRequestErrorType,\n  formatTransactionRequest,\n  type FormatTransactionRequestErrorType,\n  rpcTransactionType,\n} from './utils/formatters/transactionRequest.js'\nexport {\n  type GetAbiItemErrorType,\n  type GetAbiItemParameters,\n  type GetAbiItemReturnType,\n  getAbiItem,\n} from './utils/abi/getAbiItem.js'\nexport {\n  type GetContractAddressOptions,\n  type GetCreate2AddressOptions,\n  type GetCreate2AddressErrorType,\n  type GetCreateAddressOptions,\n  type GetCreateAddressErrorType,\n  getContractAddress,\n  getCreate2Address,\n  getCreateAddress,\n} from './utils/address/getContractAddress.js'\nexport {\n  type GetSerializedTransactionType,\n  type GetSerializedTransactionTypeErrorType,\n  getSerializedTransactionType,\n} from './utils/transaction/getSerializedTransactionType.js'\nexport {\n  type GetTransactionType,\n  type GetTransactionTypeErrorType,\n  getTransactionType,\n} from './utils/transaction/getTransactionType.js'\nexport {\n  type HashDomainErrorType,\n  type HashTypedDataErrorType,\n  type HashTypedDataParameters,\n  type HashTypedDataReturnType,\n  hashDomain,\n  hashTypedData,\n} from './utils/signature/hashTypedData.js'\nexport {\n  type CompactSignatureToSignatureErrorType,\n  compactSignatureToSignature,\n} from './utils/signature/compactSignatureToSignature.js'\nexport {\n  /** @deprecated Use `ParseCompactSignatureErrorType`. */\n  type ParseCompactSignatureErrorType as HexToCompactSignatureErrorType,\n  /** @deprecated Use `parseCompactSignature`. */\n  parseCompactSignature as hexToCompactSignature,\n  type ParseCompactSignatureErrorType,\n  parseCompactSignature,\n} from './utils/signature/parseCompactSignature.js'\nexport {\n  /** @deprecated Use `ParseSignatureErrorType`. */\n  type ParseSignatureErrorType as HexToSignatureErrorType,\n  /** @deprecated Use `parseSignature`. */\n  parseSignature as hexToSignature,\n  type ParseSignatureErrorType,\n  parseSignature,\n} from './utils/signature/parseSignature.js'\nexport {\n  type RecoverAddressErrorType,\n  type RecoverAddressParameters,\n  type RecoverAddressReturnType,\n  recoverAddress,\n} from './utils/signature/recoverAddress.js'\nexport {\n  type RecoverMessageAddressErrorType,\n  type RecoverMessageAddressParameters,\n  type RecoverMessageAddressReturnType,\n  recoverMessageAddress,\n} from './utils/signature/recoverMessageAddress.js'\nexport {\n  type RecoverPublicKeyErrorType,\n  type RecoverPublicKeyParameters,\n  type RecoverPublicKeyReturnType,\n  recoverPublicKey,\n} from './utils/signature/recoverPublicKey.js'\nexport {\n  type RecoverTransactionAddressErrorType,\n  type RecoverTransactionAddressParameters,\n  type RecoverTransactionAddressReturnType,\n  recoverTransactionAddress,\n} from './utils/signature/recoverTransactionAddress.js'\nexport {\n  type RecoverTypedDataAddressErrorType,\n  type RecoverTypedDataAddressParameters,\n  type RecoverTypedDataAddressReturnType,\n  recoverTypedDataAddress,\n} from './utils/signature/recoverTypedDataAddress.js'\nexport {\n  type SignatureToCompactSignatureErrorType,\n  signatureToCompactSignature,\n} from './utils/signature/signatureToCompactSignature.js'\nexport {\n  /** @deprecated Use `SignatureToHexErrorType` instead. */\n  type SerializeCompactSignatureErrorType as CompactSignatureToHexErrorType,\n  /** @deprecated Use `serializeCompactSignature` instead. */\n  serializeCompactSignature as compactSignatureToHex,\n  type SerializeCompactSignatureErrorType,\n  serializeCompactSignature,\n} from './utils/signature/serializeCompactSignature.js'\nexport {\n  /** @deprecated Use `SignatureToHexErrorType` instead. */\n  type SerializeSignatureErrorType as SignatureToHexErrorType,\n  /** @deprecated Use `serializeSignature` instead. */\n  serializeSignature as signatureToHex,\n  type SerializeSignatureParameters,\n  type SerializeSignatureReturnType,\n  type SerializeSignatureErrorType,\n  serializeSignature,\n} from './utils/signature/serializeSignature.js'\nexport {\n  bytesToRlp,\n  type BytesToRlpErrorType,\n  hexToRlp,\n  type HexToRlpErrorType,\n  toRlp,\n  type ToRlpErrorType,\n  type ToRlpReturnType,\n} from './utils/encoding/toRlp.js'\nexport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  type VerifyHashReturnType,\n  verifyHash,\n} from './utils/signature/verifyHash.js'\nexport {\n  type VerifyMessageErrorType,\n  type VerifyMessageParameters,\n  type VerifyMessageReturnType,\n  verifyMessage,\n} from './utils/signature/verifyMessage.js'\nexport {\n  type VerifyTypedDataErrorType,\n  type VerifyTypedDataParameters,\n  type VerifyTypedDataReturnType,\n  verifyTypedData,\n} from './utils/signature/verifyTypedData.js'\nexport {\n  type ParseErc6492SignatureErrorType,\n  type ParseErc6492SignatureParameters,\n  type ParseErc6492SignatureReturnType,\n  parseErc6492Signature,\n} from './utils/signature/parseErc6492Signature.js'\nexport {\n  type IsErc6492SignatureErrorType,\n  type IsErc6492SignatureParameters,\n  type IsErc6492SignatureReturnType,\n  isErc6492Signature,\n} from './utils/signature/isErc6492Signature.js'\nexport {\n  type SerializeErc6492SignatureErrorType,\n  type SerializeErc6492SignatureParameters,\n  type SerializeErc6492SignatureReturnType,\n  serializeErc6492Signature,\n} from './utils/signature/serializeErc6492Signature.js'\nexport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from './utils/transaction/assertRequest.js'\nexport {\n  type AssertTransactionEIP1559ErrorType,\n  assertTransactionEIP1559,\n  type AssertTransactionEIP2930ErrorType,\n  assertTransactionEIP2930,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionLegacy,\n} from './utils/transaction/assertTransaction.js'\nexport {\n  type BoolToBytesErrorType,\n  type BoolToBytesOpts,\n  boolToBytes,\n  type HexToBytesErrorType,\n  type HexToBytesOpts,\n  hexToBytes,\n  type NumberToBytesErrorType,\n  numberToBytes,\n  type StringToBytesErrorType,\n  type StringToBytesOpts,\n  stringToBytes,\n  type ToBytesErrorType,\n  type ToBytesParameters,\n  toBytes,\n} from './utils/encoding/toBytes.js'\nexport {\n  type BoolToHexErrorType,\n  type BoolToHexOpts,\n  boolToHex,\n  type BytesToHexErrorType,\n  type BytesToHexOpts,\n  bytesToHex,\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n  type StringToHexErrorType,\n  type StringToHexOpts,\n  stringToHex,\n  type ToHexErrorType,\n  type ToHexParameters,\n  toHex,\n} from './utils/encoding/toHex.js'\nexport {\n  type BytesToBigIntErrorType,\n  type BytesToBigIntOpts,\n  bytesToBigInt,\n  type BytesToBoolErrorType,\n  type BytesToBoolOpts,\n  bytesToBool,\n  type BytesToNumberErrorType,\n  type BytesToNumberOpts,\n  bytesToNumber,\n  type BytesToStringErrorType,\n  type BytesToStringOpts,\n  bytesToString,\n  type FromBytesErrorType,\n  type FromBytesParameters,\n  fromBytes,\n} from './utils/encoding/fromBytes.js'\nexport {\n  type CcipRequestParameters,\n  type CcipRequestErrorType,\n  ccipRequest,\n  /** @deprecated Use `ccipRequest`. */\n  ccipRequest as ccipFetch,\n  type OffchainLookupErrorType,\n  offchainLookup,\n  offchainLookupAbiItem,\n  offchainLookupSignature,\n} from './utils/ccip.js'\nexport {\n  type BlobsToCommitmentsErrorType,\n  type BlobsToCommitmentsParameters,\n  type BlobsToCommitmentsReturnType,\n  blobsToCommitments,\n} from './utils/blob/blobsToCommitments.js'\nexport {\n  type CommitmentToVersionedHashErrorType,\n  type CommitmentToVersionedHashParameters,\n  type CommitmentToVersionedHashReturnType,\n  commitmentToVersionedHash,\n} from './utils/blob/commitmentToVersionedHash.js'\nexport {\n  type CommitmentsToVersionedHashesErrorType,\n  type CommitmentsToVersionedHashesParameters,\n  type CommitmentsToVersionedHashesReturnType,\n  commitmentsToVersionedHashes,\n} from './utils/blob/commitmentsToVersionedHashes.js'\nexport {\n  type SidecarsToVersionedHashesErrorType,\n  type SidecarsToVersionedHashesParameters,\n  type SidecarsToVersionedHashesReturnType,\n  sidecarsToVersionedHashes,\n} from './utils/blob/sidecarsToVersionedHashes.js'\nexport {\n  type blobsToProofsErrorType,\n  type blobsToProofsParameters,\n  type blobsToProofsReturnType,\n  blobsToProofs,\n} from './utils/blob/blobsToProofs.js'\nexport {\n  type FromBlobsErrorType,\n  type FromBlobsParameters,\n  type FromBlobsReturnType,\n  fromBlobs,\n} from './utils/blob/fromBlobs.js'\nexport {\n  type ToBlobSidecarsErrorType,\n  type ToBlobSidecarsParameters,\n  type ToBlobSidecarsReturnType,\n  toBlobSidecars,\n} from './utils/blob/toBlobSidecars.js'\nexport {\n  type ToBlobsErrorType,\n  type ToBlobsParameters,\n  type ToBlobsReturnType,\n  toBlobs,\n} from './utils/blob/toBlobs.js'\nexport {\n  type DefineKzgErrorType,\n  type DefineKzgParameters,\n  type DefineKzgReturnType,\n  defineKzg,\n} from './utils/kzg/defineKzg.js'\nexport {\n  type SetupKzgErrorType,\n  type SetupKzgParameters,\n  type SetupKzgReturnType,\n  setupKzg,\n} from './utils/kzg/setupKzg.js'\nexport {\n  type ConcatBytesErrorType,\n  type ConcatErrorType,\n  type ConcatHexErrorType,\n  type ConcatReturnType,\n  concat,\n  concatBytes,\n  concatHex,\n} from './utils/data/concat.js'\nexport {\n  type AssertCurrentChainErrorType,\n  type AssertCurrentChainParameters,\n  assertCurrentChain,\n} from './utils/chain/assertCurrentChain.js'\nexport { defineChain } from './utils/chain/defineChain.js'\nexport {\n  type ExtractChainErrorType,\n  type ExtractChainParameters,\n  type ExtractChainReturnType,\n  extractChain,\n} from './utils/chain/extractChain.js'\nexport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from './utils/chain/getChainContractAddress.js'\nexport {\n  type EncodePackedErrorType,\n  encodePacked,\n} from './utils/abi/encodePacked.js'\nexport {\n  type WithRetryErrorType,\n  withRetry,\n} from './utils/promise/withRetry.js'\nexport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from './utils/promise/withTimeout.js'\nexport {\n  type FormatEtherErrorType,\n  formatEther,\n} from './utils/unit/formatEther.js'\nexport {\n  type FormatGweiErrorType,\n  formatGwei,\n} from './utils/unit/formatGwei.js'\nexport {\n  type FormatUnitsErrorType,\n  formatUnits,\n} from './utils/unit/formatUnits.js'\nexport {\n  type FromHexErrorType,\n  fromHex,\n  type HexToBigIntErrorType,\n  hexToBigInt,\n  type HexToBoolErrorType,\n  hexToBool,\n  type HexToNumberErrorType,\n  hexToNumber,\n  type HexToStringErrorType,\n  hexToString,\n} from './utils/encoding/fromHex.js'\nexport {\n  type FromRlpErrorType,\n  type FromRlpReturnType,\n  fromRlp,\n} from './utils/encoding/fromRlp.js'\nexport {\n  type ChecksumAddressErrorType,\n  type GetAddressErrorType,\n  checksumAddress,\n  getAddress,\n} from './utils/address/getAddress.js'\nexport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from './utils/errors/getContractError.js'\nexport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n  /** @deprecated use `ToEventSelectorErrorType`. */\n  type ToEventSelectorErrorType as GetEventSelectorErrorType,\n  /** @deprecated use `toEventSelector`. */\n  toEventSelector as getEventSelector,\n} from './utils/hash/toEventSelector.js'\nexport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n  /** @deprecated use `ToFunctionSelectorErrorType`. */\n  type ToFunctionSelectorErrorType as GetFunctionSelectorErrorType,\n  /** @deprecated use `toFunctionSelector`. */\n  toFunctionSelector as getFunctionSelector,\n} from './utils/hash/toFunctionSelector.js'\nexport {\n  type ToEventSignatureErrorType,\n  toEventSignature,\n  /** @deprecated use `ToEventSignatureErrorType`. */\n  type ToEventSignatureErrorType as GetEventSignatureErrorType,\n  /** @deprecated use `toEventSignature`. */\n  toEventSignature as getEventSignature,\n} from './utils/hash/toEventSignature.js'\nexport {\n  type ToFunctionSignatureErrorType,\n  toFunctionSignature,\n  /** @deprecated use `ToFunctionSignatureErrorType`. */\n  type ToFunctionSignatureErrorType as GetFunctionSignatureErrorType,\n  /** @deprecated use `toFunctionSignature`. */\n  toFunctionSignature as getFunctionSignature,\n} from './utils/hash/toFunctionSignature.js'\nexport {\n  type ToEventHashErrorType,\n  toEventHash,\n} from './utils/hash/toEventHash.js'\nexport {\n  type ToFunctionHashErrorType,\n  toFunctionHash,\n} from './utils/hash/toFunctionHash.js'\nexport {\n  type HashMessageErrorType,\n  hashMessage,\n} from './utils/signature/hashMessage.js'\nexport {\n  type ToPrefixedMessageErrorType,\n  toPrefixedMessage,\n} from './utils/signature/toPrefixedMessage.js'\nexport {\n  type IsAddressOptions,\n  type IsAddressErrorType,\n  isAddress,\n} from './utils/address/isAddress.js'\nexport {\n  type IsAddressEqualReturnType,\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from './utils/address/isAddressEqual.js'\nexport { type IsBytesErrorType, isBytes } from './utils/data/isBytes.js'\nexport { type IsHashErrorType, isHash } from './utils/hash/isHash.js'\nexport { type IsHexErrorType, isHex } from './utils/data/isHex.js'\nexport {\n  type Keccak256Hash,\n  type Keccak256ErrorType,\n  keccak256,\n} from './utils/hash/keccak256.js'\nexport {\n  type Sha256Hash,\n  type Sha256ErrorType,\n  sha256,\n} from './utils/hash/sha256.js'\nexport {\n  type Ripemd160Hash,\n  type Ripemd160ErrorType,\n  ripemd160,\n} from './utils/hash/ripemd160.js'\nexport {\n  type PadBytesErrorType,\n  type PadErrorType,\n  type PadHexErrorType,\n  type PadReturnType,\n  pad,\n  padBytes,\n  padHex,\n} from './utils/data/pad.js'\nexport {\n  type ParseEtherErrorType,\n  parseEther,\n} from './utils/unit/parseEther.js'\nexport { type ParseGweiErrorType, parseGwei } from './utils/unit/parseGwei.js'\nexport {\n  type ParseTransactionErrorType,\n  type ParseTransactionReturnType,\n  parseTransaction,\n} from './utils/transaction/parseTransaction.js'\nexport {\n  type ParseUnitsErrorType,\n  parseUnits,\n} from './utils/unit/parseUnits.js'\nexport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './utils/transaction/serializeAccessList.js'\nexport {\n  serializeTransaction,\n  type SerializeTransactionErrorType,\n  type SerializedTransactionReturnType,\n  type SerializeTransactionFn,\n} from './utils/transaction/serializeTransaction.js'\nexport { type SizeErrorType, size } from './utils/data/size.js'\nexport {\n  type SliceBytesErrorType,\n  type SliceErrorType,\n  type SliceHexErrorType,\n  slice,\n  sliceBytes,\n  sliceHex,\n} from './utils/data/slice.js'\nexport { type StringifyErrorType, stringify } from './utils/stringify.js'\nexport {\n  type TrimErrorType,\n  type TrimReturnType,\n  trim,\n} from './utils/data/trim.js'\nexport {\n  type DomainSeparatorErrorType,\n  type GetTypesForEIP712DomainErrorType,\n  type SerializeTypedDataErrorType,\n  type ValidateTypedDataErrorType,\n  serializeTypedData,\n  validateTypedData,\n  domainSeparator,\n  getTypesForEIP712Domain,\n} from './utils/typedData.js'\nexport {\n  type CreateNonceManagerParameters,\n  type NonceManager,\n  type NonceManagerSource,\n  createNonceManager,\n  nonceManager,\n} from './utils/nonceManager.js'\nexport type {\n  RpcEstimateUserOperationGasReturnType,\n  RpcGetUserOperationByHashReturnType,\n  RpcUserOperation,\n  RpcUserOperationReceipt,\n  RpcUserOperationRequest,\n} from './account-abstraction/types/rpc.js'\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\ntype HashStructErrorType = EncodeDataErrorType | Keccak256ErrorType | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { toPrefixedMessage } from './toPrefixedMessage.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessageReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType = Keccak256ErrorType | ErrorType\n\nexport function hashMessage<to extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: to | undefined,\n): HashMessageReturnType<to> {\n  return keccak256(toPrefixedMessage(message), to_)\n}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { size } from '../data/size.js'\nimport {\n  type BytesToHexErrorType,\n  type StringToHexErrorType,\n  bytesToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type ToPrefixedMessageErrorType =\n  | ConcatErrorType\n  | StringToHexErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nexport function toPrefixedMessage(message_: SignableMessage): Hex {\n  const message = (() => {\n    if (typeof message_ === 'string') return stringToHex(message_)\n    if (typeof message_.raw === 'string') return message_.raw\n    return bytesToHex(message_.raw)\n  })()\n  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)\n  return concat([prefix, message])\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAa;AAAb;;AAAO,IAAM,UAAU;;;;;ACCvB,IASa;AATb;;;AASM,IAAO,YAAP,MAAO,mBAAkB,MAAK;MAQlC,YAAY,cAAsB,OAAsB,CAAA,GAAE;AACxD,cAAM,UACJ,KAAK,iBAAiB,aAClB,KAAK,MAAM,UACX,KAAK,OAAO,UACV,KAAK,MAAM,UACX,KAAK;AACb,cAAM,WACJ,KAAK,iBAAiB,aAClB,KAAK,MAAM,YAAY,KAAK,WAC5B,KAAK;AACX,cAAM,UAAU;UACd,gBAAgB;UAChB;UACA,GAAI,KAAK,eAAe,CAAC,GAAG,KAAK,cAAc,EAAE,IAAI,CAAA;UACrD,GAAI,WAAW,CAAC,4BAA4B,QAAQ,EAAE,IAAI,CAAA;UAC1D,GAAI,UAAU,CAAC,YAAY,OAAO,EAAE,IAAI,CAAA;UACxC,oBAAoB,OAAO;UAC3B,KAAK,IAAI;AAEX,cAAM,OAAO;AA3Bf,eAAA,eAAA,MAAA,WAAA;;;;;;AACA,eAAA,eAAA,MAAA,YAAA;;;;;;AACA,eAAA,eAAA,MAAA,gBAAA;;;;;;AACA,eAAA,eAAA,MAAA,gBAAA;;;;;;AAES,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;AAwBd,YAAI,KAAK;AAAO,eAAK,QAAQ,KAAK;AAClC,aAAK,UAAU;AACf,aAAK,WAAW;AAChB,aAAK,eAAe,KAAK;AACzB,aAAK,eAAe;MACtB;;;;;;AC3CI,SAAU,UAAgB,OAAe,QAAc;AAC3D,QAAM,QAAQ,MAAM,KAAK,MAAM;AAC/B,SAAO,OAAO;AAChB;AALA,IASa,YAIA,cAGA;AAhBb;;AASO,IAAM,aAAa;AAInB,IAAM,eACX;AAEK,IAAM,eAAe;;;;;ACoCtB,SAAU,kBAAkB,WAAiB;AACjD,SAAO,qBAAqB,KAAK,SAAS;AAC5C;AACM,SAAU,oBAAoB,WAAiB;AACnD,SAAO,UACL,sBACA,SAAS;AAEb;AA3DA,IAiDM,sBAsCO,WAOA;AA9Fb;;;AAiDA,IAAM,uBACJ;AAqCK,IAAM,YAAY,oBAAI,IAAc;MACzC;MACA;MACA;MACA;KACD;AAEM,IAAM,oBAAoB,oBAAI,IAAsB;MACzD;MACA;MACA;KACD;;;;;ACnGD,IAaa,kBAYA;AAzBb;;;AAaM,IAAO,mBAAP,cAAgC,UAAS;MAG7C,YAAY,EAAE,KAAI,GAAoB;AACpC,cAAM,iBAAiB;UACrB,cAAc;YACZ,SAAS,IAAI;;SAEhB;AAPM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAQhB;;AAGI,IAAO,2BAAP,cAAwC,UAAS;MAGrD,YAAY,EAAE,KAAI,GAAoB;AACpC,cAAM,iBAAiB;UACrB,cAAc,CAAC,SAAS,IAAI,4BAA4B;SACzD;AALM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAMhB;;;;;;AC/BF,IAca,2BAWA,uBAUA,+BAaA,sBAuBA,8BAwBA;AA/Fb;;;AAcM,IAAO,4BAAP,cAAyC,UAAS;MAGtD,YAAY,EAAE,OAAM,GAA+B;AACjD,cAAM,mCAAmC;UACvC,SAAS,sBAAsB,KAAK,UAAU,QAAQ,MAAM,CAAC,CAAC;UAC9D,UAAU;SACX;AANM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAOhB;;AAGI,IAAO,wBAAP,cAAqC,UAAS;MAGlD,YAAY,EAAE,MAAK,GAAqB;AACtC,cAAM,0BAA0B;UAC9B,SAAS;SACV;AALM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAMhB;;AAGI,IAAO,gCAAP,cAA6C,UAAS;MAG1D,YAAY,EAAE,OAAO,KAAI,GAAmC;AAC1D,cAAM,0BAA0B;UAC9B,SAAS;UACT,cAAc;YACZ,IAAI,IAAI;;SAEX;AARM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAShB;;AAGI,IAAO,uBAAP,cAAoC,UAAS;MAGjD,YAAY,EACV,OACA,MACA,SAAQ,GAKT;AACC,cAAM,0BAA0B;UAC9B,SAAS;UACT,cAAc;YACZ,aAAa,QAAQ,gBACnB,OAAO,QAAQ,IAAI,WAAW,EAChC;;SAEH;AAlBM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAmBhB;;AAGI,IAAO,+BAAP,cAA4C,UAAS;MAGzD,YAAY,EACV,OACA,MACA,SAAQ,GAKT;AACC,cAAM,0BAA0B;UAC9B,SAAS;UACT,cAAc;YACZ,aAAa,QAAQ,gBACnB,OAAO,QAAQ,IAAI,WAAW,EAChC;YACA,iFAAiF,QAAQ;;SAE5F;AAnBM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAoBhB;;AAGI,IAAO,+BAAP,cAA4C,UAAS;MAGzD,YAAY,EACV,aAAY,GAGb;AACC,cAAM,0BAA0B;UAC9B,SAAS,KAAK,UAAU,cAAc,MAAM,CAAC;UAC7C,cAAc,CAAC,gCAAgC;SAChD;AAVM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAWhB;;;;;;AC3GF,IAEa,uBA0BA;AA5Bb;;;AAEM,IAAO,wBAAP,cAAqC,UAAS;MAGlD,YAAY,EACV,WACA,KAAI,GAIL;AACC,cAAM,WAAW,IAAI,eAAe;UAClC,SAAS;SACV;AAXM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAYhB;;AAaI,IAAO,8BAAP,cAA2C,UAAS;MAGxD,YAAY,EAAE,UAAS,GAAyB;AAC9C,cAAM,6BAA6B;UACjC,SAAS;UACT,cAAc,CAAC,sBAAsB;SACtC;AANM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAOhB;;;;;;ACrCF,IAEa;AAFb;;;AAEM,IAAO,yBAAP,cAAsC,UAAS;MAGnD,YAAY,EAAE,KAAI,GAAoB;AACpC,cAAM,gCAAgC;UACpC,cAAc,CAAC,WAAW,IAAI,4BAA4B;SAC3D;AALM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAMhB;;;;;;ACTF,IAEa;AAFb;;;AAEM,IAAO,0BAAP,cAAuC,UAAS;MAGpD,YAAY,EAAE,SAAS,MAAK,GAAsC;AAChE,cAAM,2BAA2B;UAC/B,cAAc;YACZ,IAAI,QAAQ,KAAI,CAAE,kBAChB,QAAQ,IAAI,YAAY,SAC1B;;UAEF,SAAS,UAAU,KAAK;SACzB;AAVM,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;MAWhB;;;;;;ACLI,SAAU,qBACd,OACA,MACA,SAAsB;AAEtB,MAAI,YAAY;AAChB,MAAI;AACF,eAAW,UAAU,OAAO,QAAQ,OAAO,GAAG;AAC5C,UAAI,CAAC;AAAQ;AACb,UAAI,cAAc;AAClB,iBAAW,YAAY,OAAO,CAAC,GAAG;AAChC,uBAAe,IAAI,SAAS,IAAI,GAAG,SAAS,OAAO,IAAI,SAAS,IAAI,KAAK,EAAE;MAC7E;AACA,mBAAa,IAAI,OAAO,CAAC,CAAC,IAAI,WAAW;IAC3C;AACF,MAAI;AAAM,WAAO,GAAG,IAAI,IAAI,KAAK,GAAG,SAAS;AAC7C,SAAO;AACT;AAvBA,IA8Ba;AA9Bb;;AA8BO,IAAM,iBAAiB,oBAAI,IAGhC;;MAEA,CAAC,WAAW,EAAE,MAAM,UAAS,CAAE;MAC/B,CAAC,QAAQ,EAAE,MAAM,OAAM,CAAE;MACzB,CAAC,SAAS,EAAE,MAAM,QAAO,CAAE;MAC3B,CAAC,WAAW,EAAE,MAAM,UAAS,CAAE;MAC/B,CAAC,OAAO,EAAE,MAAM,SAAQ,CAAE;MAC1B,CAAC,UAAU,EAAE,MAAM,SAAQ,CAAE;MAC7B,CAAC,UAAU,EAAE,MAAM,SAAQ,CAAE;MAC7B,CAAC,QAAQ,EAAE,MAAM,UAAS,CAAE;MAC5B,CAAC,SAAS,EAAE,MAAM,QAAO,CAAE;MAC3B,CAAC,UAAU,EAAE,MAAM,SAAQ,CAAE;MAC7B,CAAC,UAAU,EAAE,MAAM,SAAQ,CAAE;MAC7B,CAAC,UAAU,EAAE,MAAM,SAAQ,CAAE;MAC7B,CAAC,UAAU,EAAE,MAAM,SAAQ,CAAE;MAC7B,CAAC,UAAU,EAAE,MAAM,SAAQ,CAAE;MAC7B,CAAC,WAAW,EAAE,MAAM,UAAS,CAAE;MAC/B,CAAC,WAAW,EAAE,MAAM,UAAS,CAAE;MAC/B,CAAC,WAAW,EAAE,MAAM,UAAS,CAAE;MAC/B,CAAC,WAAW,EAAE,MAAM,UAAS,CAAE;;MAG/B,CAAC,iBAAiB,EAAE,MAAM,WAAW,MAAM,QAAO,CAAE;MACpD,CAAC,cAAc,EAAE,MAAM,WAAW,MAAM,KAAI,CAAE;MAC9C,CAAC,iBAAiB,EAAE,MAAM,QAAQ,MAAM,WAAU,CAAE;MACpD,CAAC,eAAe,EAAE,MAAM,SAAS,MAAM,QAAO,CAAE;MAChD,CAAC,cAAc,EAAE,MAAM,SAAS,MAAM,OAAM,CAAE;MAC9C,CAAC,mBAAmB,EAAE,MAAM,SAAS,MAAM,YAAW,CAAE;MACxD,CAAC,gBAAgB,EAAE,MAAM,WAAW,MAAM,OAAM,CAAE;MAClD,CAAC,aAAa,EAAE,MAAM,WAAW,MAAM,IAAG,CAAE;MAC5C,CAAC,gBAAgB,EAAE,MAAM,WAAW,MAAM,OAAM,CAAE;MAClD,CAAC,aAAa,EAAE,MAAM,WAAW,MAAM,IAAG,CAAE;MAC5C,CAAC,eAAe,EAAE,MAAM,UAAU,MAAM,OAAM,CAAE;MAChD,CAAC,iBAAiB,EAAE,MAAM,UAAU,MAAM,SAAQ,CAAE;MACpD,CAAC,mBAAmB,EAAE,MAAM,UAAU,MAAM,WAAU,CAAE;MACxD,CAAC,gBAAgB,EAAE,MAAM,WAAW,MAAM,UAAS,CAAE;MACrD,CAAC,WAAW,EAAE,MAAM,SAAS,MAAM,IAAG,CAAE;MACxC,CAAC,mBAAmB,EAAE,MAAM,WAAW,MAAM,UAAS,CAAE;MACxD,CAAC,mBAAmB,EAAE,MAAM,WAAW,MAAM,UAAS,CAAE;MACxD,CAAC,iBAAiB,EAAE,MAAM,WAAW,MAAM,QAAO,CAAE;;MAGpD;QACE;QACA,EAAE,MAAM,WAAW,MAAM,QAAQ,SAAS,KAAI;;MAEhD,CAAC,4BAA4B,EAAE,MAAM,WAAW,MAAM,MAAM,SAAS,KAAI,CAAE;MAC3E;QACE;QACA,EAAE,MAAM,WAAW,MAAM,WAAW,SAAS,KAAI;;MAEnD;QACE;QACA,EAAE,MAAM,WAAW,MAAM,WAAW,SAAS,KAAI;;KAEpD;;;;;ACuEK,SAAU,kBAAkB,OAAe,SAAsB;AAErE,QAAM,oBAAoB,qBACxB,OACA,SAAS,MACT,SAAS,OAAO;AAElB,MAAI,eAAe,IAAI,iBAAiB;AACtC,WAAO,eAAe,IAAI,iBAAiB;AAE7C,QAAM,UAAU,aAAa,KAAK,KAAK;AACvC,QAAM,QAAQ,UAMZ,UAAU,6BAA6B,+BACvC,KAAK;AAEP,MAAI,CAAC;AAAO,UAAM,IAAI,sBAAsB,EAAE,MAAK,CAAE;AAErD,MAAI,MAAM,QAAQ,kBAAkB,MAAM,IAAI;AAC5C,UAAM,IAAI,8BAA8B,EAAE,OAAO,MAAM,MAAM,KAAI,CAAE;AAErE,QAAM,OAAO,MAAM,OAAO,EAAE,MAAM,MAAM,KAAI,IAAK,CAAA;AACjD,QAAM,UAAU,MAAM,aAAa,YAAY,EAAE,SAAS,KAAI,IAAK,CAAA;AACnE,QAAM,UAAU,SAAS,WAAW,CAAA;AACpC,MAAI;AACJ,MAAI,aAAa,CAAA;AACjB,MAAI,SAAS;AACX,WAAO;AACP,UAAM,SAAS,gBAAgB,MAAM,IAAI;AACzC,UAAM,cAAc,CAAA;AACpB,UAAM,SAAS,OAAO;AACtB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAE/B,kBAAY,KAAK,kBAAkB,OAAO,CAAC,GAAI,EAAE,QAAO,CAAE,CAAC;IAC7D;AACA,iBAAa,EAAE,YAAY,YAAW;EACxC,WAAW,MAAM,QAAQ,SAAS;AAChC,WAAO;AACP,iBAAa,EAAE,YAAY,QAAQ,MAAM,IAAI,EAAC;EAChD,WAAW,oBAAoB,KAAK,MAAM,IAAI,GAAG;AAC/C,WAAO,GAAG,MAAM,IAAI;EACtB,OAAO;AACL,WAAO,MAAM;AACb,QAAI,EAAE,SAAS,SAAS,aAAa,CAAC,eAAe,IAAI;AACvD,YAAM,IAAI,yBAAyB,EAAE,KAAI,CAAE;EAC/C;AAEA,MAAI,MAAM,UAAU;AAElB,QAAI,CAAC,SAAS,WAAW,MAAM,MAAM,QAAQ;AAC3C,YAAM,IAAI,qBAAqB;QAC7B;QACA,MAAM,SAAS;QACf,UAAU,MAAM;OACjB;AAGH,QACE,kBAAkB,IAAI,MAAM,QAA4B,KACxD,CAAC,oBAAoB,MAAM,CAAC,CAAC,MAAM,KAAK;AAExC,YAAM,IAAI,6BAA6B;QACrC;QACA,MAAM,SAAS;QACf,UAAU,MAAM;OACjB;EACL;AAEA,QAAM,eAAe;IACnB,MAAM,GAAG,IAAI,GAAG,MAAM,SAAS,EAAE;IACjC,GAAG;IACH,GAAG;IACH,GAAG;;AAEL,iBAAe,IAAI,mBAAmB,YAAY;AAClD,SAAO;AACT;AAGM,SAAU,gBACd,QACA,SAAmB,CAAA,GACnB,UAAU,IACV,QAAQ,GAAC;AAET,QAAM,SAAS,OAAO,KAAI,EAAG;AAE7B,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,UAAM,OAAO,OAAO,CAAC;AACrB,UAAM,OAAO,OAAO,MAAM,IAAI,CAAC;AAC/B,YAAQ,MAAM;MACZ,KAAK;AACH,eAAO,UAAU,IACb,gBAAgB,MAAM,CAAC,GAAG,QAAQ,QAAQ,KAAI,CAAE,CAAC,IACjD,gBAAgB,MAAM,QAAQ,GAAG,OAAO,GAAG,IAAI,IAAI,KAAK;MAC9D,KAAK;AACH,eAAO,gBAAgB,MAAM,QAAQ,GAAG,OAAO,GAAG,IAAI,IAAI,QAAQ,CAAC;MACrE,KAAK;AACH,eAAO,gBAAgB,MAAM,QAAQ,GAAG,OAAO,GAAG,IAAI,IAAI,QAAQ,CAAC;MACrE;AACE,eAAO,gBAAgB,MAAM,QAAQ,GAAG,OAAO,GAAG,IAAI,IAAI,KAAK;IACnE;EACF;AAEA,MAAI,YAAY;AAAI,WAAO;AAC3B,MAAI,UAAU;AAAG,UAAM,IAAI,wBAAwB,EAAE,SAAS,MAAK,CAAE;AAErE,SAAO,KAAK,QAAQ,KAAI,CAAE;AAC1B,SAAO;AACT;AAEM,SAAU,eACd,MAAY;AAEZ,SACE,SAAS,aACT,SAAS,UACT,SAAS,cACT,SAAS,YACT,WAAW,KAAK,IAAI,KACpB,aAAa,KAAK,IAAI;AAE1B;AAMM,SAAU,kBAAkB,MAAY;AAC5C,SACE,SAAS,aACT,SAAS,UACT,SAAS,cACT,SAAS,YACT,SAAS,WACT,WAAW,KAAK,IAAI,KACpB,aAAa,KAAK,IAAI,KACtB,uBAAuB,KAAK,IAAI;AAEpC;AAGM,SAAU,oBACd,MACA,SAAgB;AAKhB,SAAO,WAAW,SAAS,WAAW,SAAS,YAAY,SAAS;AACtE;AApTA,IA8IM,+BAEA,4BAEA,qBAwIA;AA1RN;;;AAMA;AACA;AAUA;AAGA;AACA;AAyHA,IAAM,gCACJ;AACF,IAAM,6BACJ;AACF,IAAM,sBAAsB;AAwI5B,IAAM,yBACJ;;;;;ACtRI,SAAU,aAAa,YAA6B;AAExD,QAAM,iBAA+B,CAAA;AACrC,QAAM,mBAAmB,WAAW;AACpC,WAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK;AACzC,UAAM,YAAY,WAAW,CAAC;AAC9B,QAAI,CAAC,kBAAkB,SAAS;AAAG;AAEnC,UAAM,QAAQ,oBAAoB,SAAS;AAC3C,QAAI,CAAC;AAAO,YAAM,IAAI,sBAAsB,EAAE,WAAW,MAAM,SAAQ,CAAE;AAEzE,UAAM,aAAa,MAAM,WAAW,MAAM,GAAG;AAE7C,UAAM,aAA6B,CAAA;AACnC,UAAM,mBAAmB,WAAW;AACpC,aAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK;AACzC,YAAM,WAAW,WAAW,CAAC;AAC7B,YAAM,UAAU,SAAS,KAAI;AAC7B,UAAI,CAAC;AAAS;AACd,YAAM,eAAe,kBAAkB,SAAS;QAC9C,MAAM;OACP;AACD,iBAAW,KAAK,YAAY;IAC9B;AAEA,QAAI,CAAC,WAAW;AAAQ,YAAM,IAAI,4BAA4B,EAAE,UAAS,CAAE;AAC3E,mBAAe,MAAM,IAAI,IAAI;EAC/B;AAGA,QAAM,kBAAgC,CAAA;AACtC,QAAM,UAAU,OAAO,QAAQ,cAAc;AAC7C,QAAM,gBAAgB,QAAQ;AAC9B,WAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACtC,UAAM,CAAC,MAAM,UAAU,IAAI,QAAQ,CAAC;AACpC,oBAAgB,IAAI,IAAI,eAAe,YAAY,cAAc;EACnE;AAEA,SAAO;AACT;AAKA,SAAS,eACP,eACA,SACA,YAAY,oBAAI,IAAG,GAAU;AAE7B,QAAM,aAA6B,CAAA;AACnC,QAAM,SAAS,cAAc;AAC7B,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,UAAM,eAAe,cAAc,CAAC;AACpC,UAAM,UAAU,aAAa,KAAK,aAAa,IAAI;AACnD,QAAI;AAAS,iBAAW,KAAK,YAAY;SACpC;AACH,YAAM,QAAQ,UACZ,uBACA,aAAa,IAAI;AAEnB,UAAI,CAAC,OAAO;AAAM,cAAM,IAAI,6BAA6B,EAAE,aAAY,CAAE;AAEzE,YAAM,EAAE,OAAO,KAAI,IAAK;AACxB,UAAI,QAAQ,SAAS;AACnB,YAAI,UAAU,IAAI,IAAI;AAAG,gBAAM,IAAI,uBAAuB,EAAE,KAAI,CAAE;AAElE,mBAAW,KAAK;UACd,GAAG;UACH,MAAM,QAAQ,SAAS,EAAE;UACzB,YAAY,eACV,QAAQ,IAAI,KAAK,CAAA,GACjB,SACA,oBAAI,IAAI,CAAC,GAAG,WAAW,IAAI,CAAC,CAAC;SAEhC;MACH,OAAO;AACL,YAAI,eAAe,IAAI;AAAG,qBAAW,KAAK,YAAY;;AACjD,gBAAM,IAAI,iBAAiB,EAAE,KAAI,CAAE;MAC1C;IACF;EACF;AAEA,SAAO;AACT;AA/FA,IAqDM;AArDN;;;AACA;AACA;AACA;AAIA;AAEA;AACA;AA2CA,IAAM,wBACJ;;;;;AC8CI,SAAU,mBAGd,QAcG;AAEH,QAAM,gBAAgC,CAAA;AACtC,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,aAAa,gBAAgB,MAAM;AACzC,UAAM,SAAS,WAAW;AAC1B,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,oBAAc,KAAK,kBAAmB,WAAW,CAAC,GAAI,EAAE,UAAS,CAAE,CAAC;IACtE;EACF,OAAO;AACL,UAAM,UAAU,aAAa,MAA2B;AACxD,UAAM,SAAS,OAAO;AACtB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,YAAM,YAAa,OAA6B,CAAC;AACjD,UAAI,kBAAkB,SAAS;AAAG;AAClC,YAAM,aAAa,gBAAgB,SAAS;AAC5C,YAAMA,UAAS,WAAW;AAC1B,eAAS,IAAI,GAAG,IAAIA,SAAQ,KAAK;AAC/B,sBAAc,KACZ,kBAAmB,WAAW,CAAC,GAAI,EAAE,WAAW,QAAO,CAAE,CAAC;MAE9D;IACF;EACF;AAEA,MAAI,cAAc,WAAW;AAC3B,UAAM,IAAI,0BAA0B,EAAE,OAAM,CAAE;AAEhD,SAAO;AACT;AAhJA;;;AACA;AACA;AACA;AACA;;;;;AC2BA;;AAiEA;;;;;AC9FM,SAAU,MACd,OACA,EAAE,SAAS,KAAI,IAAuC,CAAA,GAAE;AAExD,MAAI,CAAC;AAAO,WAAO;AACnB,MAAI,OAAO,UAAU;AAAU,WAAO;AACtC,SAAO,SAAS,mBAAmB,KAAK,KAAK,IAAI,MAAM,WAAW,IAAI;AACxE;AAPA;;;;;;ACQM,SAAU,KAAK,OAAsB;AACzC,MAAI,MAAM,OAAO,EAAE,QAAQ,MAAK,CAAE;AAAG,WAAO,KAAK,MAAM,MAAM,SAAS,KAAK,CAAC;AAC5E,SAAO,MAAM;AACf;AAbA;;;;;;;ACHA,IAAaC;AAAb,IAAAC,gBAAA;;AAAO,IAAMD,WAAU;;;;;ACoFvB,SAAS,KACP,KACA,IAA4C;AAE5C,MAAI,KAAK,GAAG;AAAG,WAAO;AACtB,MACE,OACA,OAAO,QAAQ,YACf,WAAW,OACX,IAAI,UAAU;AAEd,WAAO,KAAK,IAAI,OAAO,EAAE;AAC3B,SAAO,KAAK,OAAO;AACrB;AAjGA,IAOI,aA6BSE;AApCb;;IAAAC;AAOA,IAAI,cAA2B;MAC7B,YAAY,CAAC,EACX,aACA,WAAW,IACX,SAAQ,MAER,WACI,GAAG,eAAe,iBAAiB,GAAG,QAAQ,GAC5C,WAAW,IAAI,QAAQ,KAAK,EAC9B,KACA;MACN,SAAS,QAAQC,QAAO;;AAkBpB,IAAOF,aAAP,MAAO,mBAAkB,MAAK;MASlC,YAAY,cAAsB,OAA4B,CAAA,GAAE;AAC9D,cAAM,WAAW,MAAK;AACpB,cAAI,KAAK,iBAAiB;AAAW,mBAAO,KAAK,MAAM;AACvD,cAAI,KAAK,OAAO;AAAS,mBAAO,KAAK,MAAM;AAC3C,iBAAO,KAAK;QACd,GAAE;AACF,cAAM,YAAY,MAAK;AACrB,cAAI,KAAK,iBAAiB;AACxB,mBAAO,KAAK,MAAM,YAAY,KAAK;AACrC,iBAAO,KAAK;QACd,GAAE;AACF,cAAM,UAAU,YAAY,aAAa,EAAE,GAAG,MAAM,SAAQ,CAAE;AAE9D,cAAM,UAAU;UACd,gBAAgB;UAChB;UACA,GAAI,KAAK,eAAe,CAAC,GAAG,KAAK,cAAc,EAAE,IAAI,CAAA;UACrD,GAAI,UAAU,CAAC,SAAS,OAAO,EAAE,IAAI,CAAA;UACrC,GAAI,UAAU,CAAC,YAAY,OAAO,EAAE,IAAI,CAAA;UACxC,GAAI,YAAY,UAAU,CAAC,YAAY,YAAY,OAAO,EAAE,IAAI,CAAA;UAChE,KAAK,IAAI;AAEX,cAAM,SAAS,KAAK,QAAQ,EAAE,OAAO,KAAK,MAAK,IAAK,MAAS;AA9B/D,eAAA,eAAA,MAAA,WAAA;;;;;;AACA,eAAA,eAAA,MAAA,YAAA;;;;;;AACA,eAAA,eAAA,MAAA,gBAAA;;;;;;AACA,eAAA,eAAA,MAAA,gBAAA;;;;;;AACA,eAAA,eAAA,MAAA,WAAA;;;;;;AAES,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;AA0Bd,aAAK,UAAU;AACf,aAAK,WAAW;AAChB,aAAK,eAAe,KAAK;AACzB,aAAK,OAAO,KAAK,QAAQ,KAAK;AAC9B,aAAK,eAAe;AACpB,aAAK,UAAUE;MACjB;MAIA,KAAK,IAAQ;AACX,eAAO,KAAK,MAAM,EAAE;MACtB;;;;;;AC9EF,IA8Ga,qCAqBA,mCAeA,gCA0NA,wBAgFA,6BA8BA;AA1db;;AACA;AAEA;AA2GM,IAAO,sCAAP,cAAmDC,WAAS;MAChE,YAAY,EACV,gBACA,aACA,KAAI,GAC0D;AAC9D,cACE;UACE,+CAA+C,IAAI;UACnD,oBAAoB,cAAc;UAClC,iBAAiB,WAAW;UAC5B,KAAK,IAAI,GACX,EAAE,MAAM,sCAAqC,CAAE;MAEnD;;AAOI,IAAO,oCAAP,cAAiDA,WAAS;MAC9D,YAAY,EAAE,cAAc,MAAK,GAAwC;AACvE,cACE,kBAAkB,KAAK,WAAW,KAChC,KAAK,CACN,wCAAwC,YAAY,MACrD,EAAE,MAAM,oCAAmC,CAAE;MAEjD;;AAOI,IAAO,iCAAP,cAA8CA,WAAS;MAC3D,YAAY,EACV,gBACA,YAAW,GACqC;AAChD,cACE;UACE;UACA,6BAA6B,cAAc;UAC3C,0BAA0B,WAAW;UACrC,KAAK,IAAI,GACX,EAAE,MAAM,iCAAgC,CAAE;MAE9C;;AA6MI,IAAO,yBAAP,cAAsCA,WAAS;MACnD,YAAY,EACV,cACA,UAAS,GACmC;AAC5C,cAAM,iBAAiB,YAAY,cAAc,SAAS,KAAK;UAC7D,MAAM;SACP;MACH;;AAwEI,IAAO,8BAAP,cAA2CA,WAAS;MACxD,YAAY,MAAc,EAAE,SAAQ,GAAwB;AAC1D,cACE;UACE,SAAS,IAAI;UACb;UACA,KAAK,IAAI,GACX,EAAE,UAAU,MAAM,yBAAwB,CAAE;MAEhD;;AAqBI,IAAO,oBAAP,cAAiCA,WAAS;MAC9C,YAAY,OAAc;AACxB,cAAM,CAAC,UAAU,KAAK,yBAAyB,EAAE,KAAK,IAAI,GAAG;UAC3D,MAAM;SACP;MACH;;;;;;ACleF,IAKa,6BAkBA;AAvBb;;;AAKM,IAAO,8BAAP,cAA2CC,WAAS;MACxD,YAAY,EACV,QACA,UACA,MAAAC,MAAI,GACwD;AAC5D,cACE,SACE,aAAa,UAAU,aAAa,QACtC,eAAe,MAAM,6BAA6BA,KAAI,MACtD,EAAE,MAAM,8BAA6B,CAAE;MAE3C;;AAMI,IAAO,8BAAP,cAA2CD,WAAS;MACxD,YAAY,EACV,MAAAC,OACA,YACA,KAAI,GAKL;AACC,cACE,GAAG,KAAK,OAAO,CAAC,EAAE,YAAW,CAAE,GAAG,KAC/B,MAAM,CAAC,EACP,YAAW,CAAE,UAAUA,KAAI,2BAA2B,UAAU,MACnE,EAAE,MAAM,8BAA6B,CAAE;MAE3C;;;;;;ACtBI,SAAU,IACd,YACA,EAAE,KAAK,MAAAC,QAAO,GAAE,IAAiB,CAAA,GAAE;AAEnC,MAAI,OAAO,eAAe;AACxB,WAAO,OAAO,YAAY,EAAE,KAAK,MAAAA,MAAI,CAAE;AACzC,SAAO,SAAS,YAAY,EAAE,KAAK,MAAAA,MAAI,CAAE;AAC3C;AAIM,SAAU,OAAO,MAAW,EAAE,KAAK,MAAAA,QAAO,GAAE,IAAiB,CAAA,GAAE;AACnE,MAAIA,UAAS;AAAM,WAAO;AAC1B,QAAM,MAAM,KAAK,QAAQ,MAAM,EAAE;AACjC,MAAI,IAAI,SAASA,QAAO;AACtB,UAAM,IAAI,4BAA4B;MACpC,MAAM,KAAK,KAAK,IAAI,SAAS,CAAC;MAC9B,YAAYA;MACZ,MAAM;KACP;AAEH,SAAO,KAAK,IAAI,QAAQ,UAAU,WAAW,UAAU,EACrDA,QAAO,GACP,GAAG,CACJ;AACH;AAIM,SAAU,SACd,OACA,EAAE,KAAK,MAAAA,QAAO,GAAE,IAAiB,CAAA,GAAE;AAEnC,MAAIA,UAAS;AAAM,WAAO;AAC1B,MAAI,MAAM,SAASA;AACjB,UAAM,IAAI,4BAA4B;MACpC,MAAM,MAAM;MACZ,YAAYA;MACZ,MAAM;KACP;AACH,QAAM,cAAc,IAAI,WAAWA,KAAI;AACvC,WAAS,IAAI,GAAG,IAAIA,OAAM,KAAK;AAC7B,UAAM,SAAS,QAAQ;AACvB,gBAAY,SAAS,IAAIA,QAAO,IAAI,CAAC,IACnC,MAAM,SAAS,IAAI,MAAM,SAAS,IAAI,CAAC;EAC3C;AACA,SAAO;AACT;AAhEA;;;;;;;ACEA,IAKa,wBAgEA;AArEb;;;AAKM,IAAO,yBAAP,cAAsCC,WAAS;MACnD,YAAY,EACV,KACA,KACA,QACA,MAAAC,OACA,MAAK,GAON;AACC,cACE,WAAW,KAAK,oBACdA,QAAO,GAAGA,QAAO,CAAC,QAAQ,SAAS,WAAW,UAAU,MAAM,EAChE,iBAAiB,MAAM,IAAI,GAAG,OAAO,GAAG,MAAM,UAAU,GAAG,GAAG,IAC9D,EAAE,MAAM,yBAAwB,CAAE;MAEtC;;AA4CI,IAAO,oBAAP,cAAiCD,WAAS;MAC9C,YAAY,EAAE,WAAW,QAAO,GAA0C;AACxE,cACE,sBAAsB,OAAO,uBAAuB,SAAS,WAC7D,EAAE,MAAM,oBAAmB,CAAE;MAEjC;;;;;;AC3DI,SAAU,WACd,YACA,EAAE,MAAAE,MAAI,GAAoB;AAE1B,MAAI,KAAM,UAAU,IAAIA;AACtB,UAAM,IAAI,kBAAkB;MAC1B,WAAW,KAAM,UAAU;MAC3B,SAASA;KACV;AACL;AA3BA;;;AAQA;;;;;AC2CM,SAAU,MACd,OACA,OAAwB,CAAA,GAAE;AAE1B,MAAI,OAAO,UAAU,YAAY,OAAO,UAAU;AAChD,WAAO,YAAY,OAAO,IAAI;AAChC,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,YAAY,OAAO,IAAI;EAChC;AACA,MAAI,OAAO,UAAU;AAAW,WAAO,UAAU,OAAO,IAAI;AAC5D,SAAO,WAAW,OAAO,IAAI;AAC/B;AAiCM,SAAU,UAAU,OAAgB,OAAsB,CAAA,GAAE;AAChE,QAAM,MAAW,KAAK,OAAO,KAAK,CAAC;AACnC,MAAI,OAAO,KAAK,SAAS,UAAU;AACjC,eAAW,KAAK,EAAE,MAAM,KAAK,KAAI,CAAE;AACnC,WAAO,IAAI,KAAK,EAAE,MAAM,KAAK,KAAI,CAAE;EACrC;AACA,SAAO;AACT;AA4BM,SAAU,WAAW,OAAkB,OAAuB,CAAA,GAAE;AACpE,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,cAAU,MAAM,MAAM,CAAC,CAAC;EAC1B;AACA,QAAM,MAAM,KAAK,MAAM;AAEvB,MAAI,OAAO,KAAK,SAAS,UAAU;AACjC,eAAW,KAAK,EAAE,MAAM,KAAK,KAAI,CAAE;AACnC,WAAO,IAAI,KAAK,EAAE,KAAK,SAAS,MAAM,KAAK,KAAI,CAAE;EACnD;AACA,SAAO;AACT;AAuCM,SAAU,YACd,QACA,OAAwB,CAAA,GAAE;AAE1B,QAAM,EAAE,QAAQ,MAAAC,MAAI,IAAK;AAEzB,QAAM,QAAQ,OAAO,MAAM;AAE3B,MAAI;AACJ,MAAIA,OAAM;AACR,QAAI;AAAQ,kBAAY,MAAO,OAAOA,KAAI,IAAI,KAAK,MAAO;;AACrD,iBAAW,OAAO,OAAOA,KAAI,IAAI,MAAM;EAC9C,WAAW,OAAO,WAAW,UAAU;AACrC,eAAW,OAAO,OAAO,gBAAgB;EAC3C;AAEA,QAAM,WAAW,OAAO,aAAa,YAAY,SAAS,CAAC,WAAW,KAAK;AAE3E,MAAK,YAAY,QAAQ,YAAa,QAAQ,UAAU;AACtD,UAAM,SAAS,OAAO,WAAW,WAAW,MAAM;AAClD,UAAM,IAAI,uBAAuB;MAC/B,KAAK,WAAW,GAAG,QAAQ,GAAG,MAAM,KAAK;MACzC,KAAK,GAAG,QAAQ,GAAG,MAAM;MACzB;MACA,MAAAA;MACA,OAAO,GAAG,MAAM,GAAG,MAAM;KAC1B;EACH;AAEA,QAAM,MAAM,MACV,UAAU,QAAQ,KAAK,MAAM,OAAOA,QAAO,CAAC,KAAK,OAAO,KAAK,IAAI,OACjE,SAAS,EAAE,CAAC;AACd,MAAIA;AAAM,WAAO,IAAI,KAAK,EAAE,MAAAA,MAAI,CAAE;AAClC,SAAO;AACT;AA8BM,SAAU,YAAY,QAAgB,OAAwB,CAAA,GAAE;AACpE,QAAM,QAAQ,QAAQ,OAAO,MAAM;AACnC,SAAO,WAAW,OAAO,IAAI;AAC/B;AAxPA,IAUM,OAsNA;AAhON;;;AAMA;AAEA;AAEA,IAAM,QAAsB,sBAAM,KAAK,EAAE,QAAQ,IAAG,GAAI,CAAC,IAAI,MAC3D,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC;AAqNjC,IAAM,UAAwB,oBAAI,YAAW;;;;;AC3KvC,SAAU,QACd,OACA,OAA0B,CAAA,GAAE;AAE5B,MAAI,OAAO,UAAU,YAAY,OAAO,UAAU;AAChD,WAAO,cAAc,OAAO,IAAI;AAClC,MAAI,OAAO,UAAU;AAAW,WAAO,YAAY,OAAO,IAAI;AAC9D,MAAI,MAAM,KAAK;AAAG,WAAO,WAAW,OAAO,IAAI;AAC/C,SAAO,cAAc,OAAO,IAAI;AAClC;AA+BM,SAAU,YAAY,OAAgB,OAAwB,CAAA,GAAE;AACpE,QAAM,QAAQ,IAAI,WAAW,CAAC;AAC9B,QAAM,CAAC,IAAI,OAAO,KAAK;AACvB,MAAI,OAAO,KAAK,SAAS,UAAU;AACjC,eAAW,OAAO,EAAE,MAAM,KAAK,KAAI,CAAE;AACrC,WAAO,IAAI,OAAO,EAAE,MAAM,KAAK,KAAI,CAAE;EACvC;AACA,SAAO;AACT;AAYA,SAAS,iBAAiB,MAAY;AACpC,MAAI,QAAQ,YAAY,QAAQ,QAAQ,YAAY;AAClD,WAAO,OAAO,YAAY;AAC5B,MAAI,QAAQ,YAAY,KAAK,QAAQ,YAAY;AAC/C,WAAO,QAAQ,YAAY,IAAI;AACjC,MAAI,QAAQ,YAAY,KAAK,QAAQ,YAAY;AAC/C,WAAO,QAAQ,YAAY,IAAI;AACjC,SAAO;AACT;AA4BM,SAAU,WAAW,MAAW,OAAuB,CAAA,GAAE;AAC7D,MAAI,MAAM;AACV,MAAI,KAAK,MAAM;AACb,eAAW,KAAK,EAAE,MAAM,KAAK,KAAI,CAAE;AACnC,UAAM,IAAI,KAAK,EAAE,KAAK,SAAS,MAAM,KAAK,KAAI,CAAE;EAClD;AAEA,MAAI,YAAY,IAAI,MAAM,CAAC;AAC3B,MAAI,UAAU,SAAS;AAAG,gBAAY,IAAI,SAAS;AAEnD,QAAM,SAAS,UAAU,SAAS;AAClC,QAAM,QAAQ,IAAI,WAAW,MAAM;AACnC,WAAS,QAAQ,GAAG,IAAI,GAAG,QAAQ,QAAQ,SAAS;AAClD,UAAM,aAAa,iBAAiB,UAAU,WAAW,GAAG,CAAC;AAC7D,UAAM,cAAc,iBAAiB,UAAU,WAAW,GAAG,CAAC;AAC9D,QAAI,eAAe,UAAa,gBAAgB,QAAW;AACzD,YAAM,IAAIC,WACR,2BAA2B,UAAU,IAAI,CAAC,CAAC,GACzC,UAAU,IAAI,CAAC,CACjB,SAAS,SAAS,KAAK;IAE3B;AACA,UAAM,KAAK,IAAI,aAAa,KAAK;EACnC;AACA,SAAO;AACT;AA0BM,SAAU,cACd,OACA,MAAkC;AAElC,QAAM,MAAM,YAAY,OAAO,IAAI;AACnC,SAAO,WAAW,GAAG;AACvB;AA+BM,SAAU,cACd,OACA,OAA0B,CAAA,GAAE;AAE5B,QAAM,QAAQC,SAAQ,OAAO,KAAK;AAClC,MAAI,OAAO,KAAK,SAAS,UAAU;AACjC,eAAW,OAAO,EAAE,MAAM,KAAK,KAAI,CAAE;AACrC,WAAO,IAAI,OAAO,EAAE,KAAK,SAAS,MAAM,KAAK,KAAI,CAAE;EACrD;AACA,SAAO;AACT;AAvPA,IAaMA,UA2FA;AAxGN;;;AAGA;AACA;AAEA;AACA;AAMA,IAAMA,WAAwB,oBAAI,YAAW;AA2F7C,IAAM,cAAc;MAClB,MAAM;MACN,MAAM;MACN,GAAG;MACH,GAAG;MACH,GAAG;MACH,GAAG;;;;;;AC9GL,SAAS,QAAQ,GAAS;AACxB,MAAI,CAAC,OAAO,cAAc,CAAC,KAAK,IAAI;AAAG,UAAM,IAAI,MAAM,oCAAoC,CAAC;AAC9F;AAGA,SAAS,QAAQ,GAAU;AACzB,SAAO,aAAa,cAAe,YAAY,OAAO,CAAC,KAAK,EAAE,YAAY,SAAS;AACrF;AAEA,SAAS,OAAO,MAA8B,SAAiB;AAC7D,MAAI,CAAC,QAAQ,CAAC;AAAG,UAAM,IAAI,MAAM,qBAAqB;AACtD,MAAI,QAAQ,SAAS,KAAK,CAAC,QAAQ,SAAS,EAAE,MAAM;AAClD,UAAM,IAAI,MAAM,mCAAmC,UAAU,kBAAkB,EAAE,MAAM;AAC3F;AAeA,SAAS,QAAQ,UAAe,gBAAgB,MAAI;AAClD,MAAI,SAAS;AAAW,UAAM,IAAI,MAAM,kCAAkC;AAC1E,MAAI,iBAAiB,SAAS;AAAU,UAAM,IAAI,MAAM,uCAAuC;AACjG;AACA,SAAS,QAAQ,KAAU,UAAa;AACtC,SAAO,GAAG;AACV,QAAM,MAAM,SAAS;AACrB,MAAI,IAAI,SAAS,KAAK;AACpB,UAAM,IAAI,MAAM,2DAA2D,GAAG;EAChF;AACF;AAtCA;;;;;;ACMA,SAAS,QAAQ,GAAW,KAAK,OAAK;AACpC,MAAI;AAAI,WAAO,EAAE,GAAG,OAAO,IAAI,UAAU,GAAG,GAAG,OAAQ,KAAK,OAAQ,UAAU,EAAC;AAC/E,SAAO,EAAE,GAAG,OAAQ,KAAK,OAAQ,UAAU,IAAI,GAAG,GAAG,OAAO,IAAI,UAAU,IAAI,EAAC;AACjF;AAEA,SAAS,MAAM,KAAe,KAAK,OAAK;AACtC,MAAI,KAAK,IAAI,YAAY,IAAI,MAAM;AACnC,MAAI,KAAK,IAAI,YAAY,IAAI,MAAM;AACnC,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,UAAM,EAAE,GAAG,EAAC,IAAK,QAAQ,IAAI,CAAC,GAAG,EAAE;AACnC,KAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;EACxB;AACA,SAAO,CAAC,IAAI,EAAE;AAChB;AAnBA,IAAM,YACA,MAkCA,QACA,QAEA,QACA;AAvCN;;IAAM,aAA6B,uBAAO,KAAK,KAAK,CAAC;AACrD,IAAM,OAAuB,uBAAO,EAAE;AAkCtC,IAAM,SAAS,CAAC,GAAW,GAAW,MAAe,KAAK,IAAM,MAAO,KAAK;AAC5E,IAAM,SAAS,CAAC,GAAW,GAAW,MAAe,KAAK,IAAM,MAAO,KAAK;AAE5E,IAAM,SAAS,CAAC,GAAW,GAAW,MAAe,KAAM,IAAI,KAAQ,MAAO,KAAK;AACnF,IAAM,SAAS,CAAC,GAAW,GAAW,MAAe,KAAM,IAAI,KAAQ,MAAO,KAAK;;;;;ACQ7E,SAAU,WAAW,KAAgB;AACzC,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI,CAAC,IAAI,SAAS,IAAI,CAAC,CAAC;EAC1B;AACF;AA0EM,SAAU,YAAY,KAAW;AACrC,MAAI,OAAO,QAAQ;AAAU,UAAM,IAAI,MAAM,sCAAsC,OAAO,GAAG;AAC7F,SAAO,IAAI,WAAW,IAAI,YAAW,EAAG,OAAO,GAAG,CAAC;AACrD;AAQM,SAAUC,SAAQ,MAAW;AACjC,MAAI,OAAO,SAAS;AAAU,WAAO,YAAY,IAAI;AACrD,SAAO,IAAI;AACX,SAAO;AACT;AAyEM,SAAU,gBAAmC,UAAuB;AACxE,QAAM,QAAQ,CAAC,QAA2B,SAAQ,EAAG,OAAOA,SAAQ,GAAG,CAAC,EAAE,OAAM;AAChF,QAAM,MAAM,SAAQ;AACpB,QAAM,YAAY,IAAI;AACtB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,MAAM,SAAQ;AAC7B,SAAO;AACT;AAaM,SAAU,2BACd,UAAkC;AAElC,QAAM,QAAQ,CAAC,KAAY,SAAyB,SAAS,IAAI,EAAE,OAAOA,SAAQ,GAAG,CAAC,EAAE,OAAM;AAC9F,QAAM,MAAM,SAAS,CAAA,CAAO;AAC5B,QAAM,YAAY,IAAI;AACtB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,CAAC,SAAY,SAAS,IAAI;AACzC,SAAO;AACT;AAlPA,IAsBa,KAaA,MAGA,UA4HS;AAlKtB,IAAAC,cAAA;;AASA;AAaO,IAAM,MAAM,CAAC,QAClB,IAAI,YAAY,IAAI,QAAQ,IAAI,YAAY,KAAK,MAAM,IAAI,aAAa,CAAC,CAAC;AAYrE,IAAM,OAAwB,uBACnC,IAAI,WAAW,IAAI,YAAY,CAAC,SAAU,CAAC,EAAE,MAAM,EAAE,CAAC,MAAM,IAAK;AAE5D,IAAM,WAAW,CAAC,SACrB,QAAQ,KAAM,aACd,QAAQ,IAAK,WACb,SAAS,IAAK,QACd,SAAS,KAAM;AAwHb,IAAgB,OAAhB,MAAoB;;MAsBxB,QAAK;AACH,eAAO,KAAK,WAAU;MACxB;;;;;;AC1II,SAAU,QAAQ,GAAgB,SAAiB,IAAE;AACzD,QAAM,IAAI,IAAI,YAAY,IAAI,CAAC;AAE/B,WAAS,QAAQ,KAAK,QAAQ,QAAQ,IAAI,SAAS;AAEjD,aAAS,IAAI,GAAG,IAAI,IAAI;AAAK,QAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AACvF,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK,GAAG;AAC9B,YAAM,QAAQ,IAAI,KAAK;AACvB,YAAM,QAAQ,IAAI,KAAK;AACvB,YAAM,KAAK,EAAE,IAAI;AACjB,YAAM,KAAK,EAAE,OAAO,CAAC;AACrB,YAAM,KAAK,MAAM,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI;AACpC,YAAM,KAAK,MAAM,IAAI,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC;AACxC,eAAS,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI;AAC/B,UAAE,IAAI,CAAC,KAAK;AACZ,UAAE,IAAI,IAAI,CAAC,KAAK;MAClB;IACF;AAEA,QAAI,OAAO,EAAE,CAAC;AACd,QAAI,OAAO,EAAE,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAM,QAAQ,UAAU,CAAC;AACzB,YAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAClC,YAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAClC,YAAM,KAAK,QAAQ,CAAC;AACpB,aAAO,EAAE,EAAE;AACX,aAAO,EAAE,KAAK,CAAC;AACf,QAAE,EAAE,IAAI;AACR,QAAE,KAAK,CAAC,IAAI;IACd;AAEA,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI;AAC/B,eAAS,IAAI,GAAG,IAAI,IAAI;AAAK,UAAE,CAAC,IAAI,EAAE,IAAI,CAAC;AAC3C,eAAS,IAAI,GAAG,IAAI,IAAI;AAAK,UAAE,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,KAAK,EAAE,IAAI,GAAG,IAAI,KAAK,EAAE;IAC5E;AAEA,MAAE,CAAC,KAAK,YAAY,KAAK;AACzB,MAAE,CAAC,KAAK,YAAY,KAAK;EAC3B;AACA,IAAE,KAAK,CAAC;AACV;AAzFA,IAkBM,SACA,WACA,YACA,KACA,KACA,KACA,KACA,OACA,QAeC,aAAa,aAGd,OACA,OA8CO,QA4GP,KAGO,UAKA,UACA,UACA,UACA,YAKA,YACA,YACA,YAIP,UAMO,UACA;AApOb;;;AACA;AACA,IAAAC;AAgBA,IAAM,UAAoB,CAAA;AAC1B,IAAM,YAAsB,CAAA;AAC5B,IAAM,aAAuB,CAAA;AAC7B,IAAM,MAAsB,uBAAO,CAAC;AACpC,IAAM,MAAsB,uBAAO,CAAC;AACpC,IAAM,MAAsB,uBAAO,CAAC;AACpC,IAAM,MAAsB,uBAAO,CAAC;AACpC,IAAM,QAAwB,uBAAO,GAAG;AACxC,IAAM,SAAyB,uBAAO,GAAI;AAC1C,aAAS,QAAQ,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,QAAQ,IAAI,SAAS;AAE9D,OAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,KAAK,CAAC;AAChC,cAAQ,KAAK,KAAK,IAAI,IAAI,EAAE;AAE5B,gBAAU,MAAQ,QAAQ,MAAM,QAAQ,KAAM,IAAK,EAAE;AAErD,UAAI,IAAI;AACR,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,aAAM,KAAK,OAAS,KAAK,OAAO,UAAW;AAC3C,YAAI,IAAI;AAAK,eAAK,QAAS,OAAuB,uBAAO,CAAC,KAAK;MACjE;AACA,iBAAW,KAAK,CAAC;IACnB;AACA,IAAM,CAAC,aAAa,eAA+B,sBAAM,YAAY,IAAI;AAGzE,IAAM,QAAQ,CAAC,GAAW,GAAW,MAAe,IAAI,KAAK,OAAO,GAAG,GAAG,CAAC,IAAI,OAAO,GAAG,GAAG,CAAC;AAC7F,IAAM,QAAQ,CAAC,GAAW,GAAW,MAAe,IAAI,KAAK,OAAO,GAAG,GAAG,CAAC,IAAI,OAAO,GAAG,GAAG,CAAC;AA8CvF,IAAO,SAAP,MAAO,gBAAe,KAAY;;MAQtC,YACS,UACA,QACA,WACG,YAAY,OACZ,SAAiB,IAAE;AAE7B,cAAK;AANE,aAAA,WAAA;AACA,aAAA,SAAA;AACA,aAAA,YAAA;AACG,aAAA,YAAA;AACA,aAAA,SAAA;AAXF,aAAA,MAAM;AACN,aAAA,SAAS;AACT,aAAA,WAAW;AAEX,aAAA,YAAY;AAWpB,gBAAQ,SAAS;AAEjB,YAAI,KAAK,KAAK,YAAY,KAAK,YAAY;AACzC,gBAAM,IAAI,MAAM,0CAA0C;AAC5D,aAAK,QAAQ,IAAI,WAAW,GAAG;AAC/B,aAAK,UAAU,IAAI,KAAK,KAAK;MAC/B;MACU,SAAM;AACd,YAAI,CAAC;AAAM,qBAAW,KAAK,OAAO;AAClC,gBAAQ,KAAK,SAAS,KAAK,MAAM;AACjC,YAAI,CAAC;AAAM,qBAAW,KAAK,OAAO;AAClC,aAAK,SAAS;AACd,aAAK,MAAM;MACb;MACA,OAAO,MAAW;AAChB,gBAAQ,IAAI;AACZ,cAAM,EAAE,UAAU,MAAK,IAAK;AAC5B,eAAOC,SAAQ,IAAI;AACnB,cAAM,MAAM,KAAK;AACjB,iBAAS,MAAM,GAAG,MAAM,OAAO;AAC7B,gBAAM,OAAO,KAAK,IAAI,WAAW,KAAK,KAAK,MAAM,GAAG;AACpD,mBAAS,IAAI,GAAG,IAAI,MAAM;AAAK,kBAAM,KAAK,KAAK,KAAK,KAAK,KAAK;AAC9D,cAAI,KAAK,QAAQ;AAAU,iBAAK,OAAM;QACxC;AACA,eAAO;MACT;MACU,SAAM;AACd,YAAI,KAAK;AAAU;AACnB,aAAK,WAAW;AAChB,cAAM,EAAE,OAAO,QAAQ,KAAK,SAAQ,IAAK;AAEzC,cAAM,GAAG,KAAK;AACd,aAAK,SAAS,SAAU,KAAK,QAAQ,WAAW;AAAG,eAAK,OAAM;AAC9D,cAAM,WAAW,CAAC,KAAK;AACvB,aAAK,OAAM;MACb;MACU,UAAU,KAAe;AACjC,gBAAQ,MAAM,KAAK;AACnB,eAAO,GAAG;AACV,aAAK,OAAM;AACX,cAAM,YAAY,KAAK;AACvB,cAAM,EAAE,SAAQ,IAAK;AACrB,iBAAS,MAAM,GAAG,MAAM,IAAI,QAAQ,MAAM,OAAO;AAC/C,cAAI,KAAK,UAAU;AAAU,iBAAK,OAAM;AACxC,gBAAM,OAAO,KAAK,IAAI,WAAW,KAAK,QAAQ,MAAM,GAAG;AACvD,cAAI,IAAI,UAAU,SAAS,KAAK,QAAQ,KAAK,SAAS,IAAI,GAAG,GAAG;AAChE,eAAK,UAAU;AACf,iBAAO;QACT;AACA,eAAO;MACT;MACA,QAAQ,KAAe;AAErB,YAAI,CAAC,KAAK;AAAW,gBAAM,IAAI,MAAM,uCAAuC;AAC5E,eAAO,KAAK,UAAU,GAAG;MAC3B;MACA,IAAI,OAAa;AACf,gBAAQ,KAAK;AACb,eAAO,KAAK,QAAQ,IAAI,WAAW,KAAK,CAAC;MAC3C;MACA,WAAW,KAAe;AACxB,gBAAQ,KAAK,IAAI;AACjB,YAAI,KAAK;AAAU,gBAAM,IAAI,MAAM,6BAA6B;AAChE,aAAK,UAAU,GAAG;AAClB,aAAK,QAAO;AACZ,eAAO;MACT;MACA,SAAM;AACJ,eAAO,KAAK,WAAW,IAAI,WAAW,KAAK,SAAS,CAAC;MACvD;MACA,UAAO;AACL,aAAK,YAAY;AACjB,aAAK,MAAM,KAAK,CAAC;MACnB;MACA,WAAW,IAAW;AACpB,cAAM,EAAE,UAAU,QAAQ,WAAW,QAAQ,UAAS,IAAK;AAC3D,eAAA,KAAO,IAAI,QAAO,UAAU,QAAQ,WAAW,WAAW,MAAM;AAChE,WAAG,QAAQ,IAAI,KAAK,OAAO;AAC3B,WAAG,MAAM,KAAK;AACd,WAAG,SAAS,KAAK;AACjB,WAAG,WAAW,KAAK;AACnB,WAAG,SAAS;AAEZ,WAAG,SAAS;AACZ,WAAG,YAAY;AACf,WAAG,YAAY;AACf,WAAG,YAAY,KAAK;AACpB,eAAO;MACT;;AAGF,IAAM,MAAM,CAAC,QAAgB,UAAkB,cAC7C,gBAAgB,MAAM,IAAI,OAAO,UAAU,QAAQ,SAAS,CAAC;AAExD,IAAM,WAA2B,oBAAI,GAAM,KAAK,MAAM,CAAC;AAKvD,IAAM,WAA2B,oBAAI,GAAM,KAAK,MAAM,CAAC;AACvD,IAAM,WAA2B,oBAAI,GAAM,KAAK,MAAM,CAAC;AACvD,IAAM,WAA2B,oBAAI,GAAM,IAAI,MAAM,CAAC;AACtD,IAAM,aAA6B,oBAAI,GAAM,KAAK,MAAM,CAAC;AAKzD,IAAM,aAA6B,oBAAI,GAAM,KAAK,MAAM,CAAC;AACzD,IAAM,aAA6B,oBAAI,GAAM,KAAK,MAAM,CAAC;AACzD,IAAM,aAA6B,oBAAI,GAAM,IAAI,MAAM,CAAC;AAI/D,IAAM,WAAW,CAAC,QAAgB,UAAkB,cAClD,2BACE,CAAC,OAAkB,CAAA,MACjB,IAAI,OAAO,UAAU,QAAQ,KAAK,UAAU,SAAY,YAAY,KAAK,OAAO,IAAI,CAAC;AAGpF,IAAM,WAA2B,yBAAS,IAAM,KAAK,MAAM,CAAC;AAC5D,IAAM,WAA2B,yBAAS,IAAM,KAAK,MAAM,CAAC;;;;;AChN7D,SAAU,UACd,OACA,KAAoB;AAEpB,QAAM,KAAK,OAAO;AAClB,QAAM,QAAQ,WACZ,MAAM,OAAO,EAAE,QAAQ,MAAK,CAAE,IAAI,QAAQ,KAAK,IAAI,KAAK;AAE1D,MAAI,OAAO;AAAS,WAAO;AAC3B,SAAO,MAAM,KAAK;AACpB;AA9BA;;;AAIA;AACA;AACA;;;;;ACNA,IAKa;AALb;;;AAKM,IAAO,sBAAP,cAAmCC,WAAS;MAChD,YAAY,EAAE,QAAO,GAAuB;AAC1C,cAAM,YAAY,OAAO,iBAAiB;UACxC,cAAc;YACZ;YACA;;UAEF,MAAM;SACP;MACH;;;;;;ACdF,IAKa;AALb;;AAKM,IAAO,SAAP,cAAuC,IAAkB;MAG7D,YAAYC,OAAY;AACtB,cAAK;AAHP,eAAA,eAAA,MAAA,WAAA;;;;;;AAIE,aAAK,UAAUA;MACjB;MAES,IAAI,KAAW;AACtB,cAAM,QAAQ,MAAM,IAAI,GAAG;AAE3B,YAAI,MAAM,IAAI,GAAG,KAAK,UAAU,QAAW;AACzC,eAAK,OAAO,GAAG;AACf,gBAAM,IAAI,KAAK,KAAK;QACtB;AAEA,eAAO;MACT;MAES,IAAI,KAAa,OAAY;AACpC,cAAM,IAAI,KAAK,KAAK;AACpB,YAAI,KAAK,WAAW,KAAK,OAAO,KAAK,SAAS;AAC5C,gBAAM,WAAW,KAAK,KAAI,EAAG,KAAI,EAAG;AACpC,cAAI;AAAU,iBAAK,OAAO,QAAQ;QACpC;AACA,eAAO;MACT;;;;;;ACZI,SAAU,gBACd,UAWA,SAA4B;AAE5B,MAAI,qBAAqB,IAAI,GAAG,QAAQ,IAAI,OAAO,EAAE;AACnD,WAAO,qBAAqB,IAAI,GAAG,QAAQ,IAAI,OAAO,EAAE;AAE1D,QAAM,aAAa,UACf,GAAG,OAAO,GAAG,SAAS,YAAW,CAAE,KACnC,SAAS,UAAU,CAAC,EAAE,YAAW;AACrC,QAAM,OAAO,UAAU,cAAc,UAAU,GAAG,OAAO;AAEzD,QAAM,WACJ,UAAU,WAAW,UAAU,GAAG,OAAO,KAAK,MAAM,IAAI,YACxD,MAAM,EAAE;AACV,WAAS,IAAI,GAAG,IAAI,IAAI,KAAK,GAAG;AAC9B,QAAI,KAAK,KAAK,CAAC,KAAK,KAAK,KAAK,QAAQ,CAAC,GAAG;AACxC,cAAQ,CAAC,IAAI,QAAQ,CAAC,EAAE,YAAW;IACrC;AACA,SAAK,KAAK,KAAK,CAAC,IAAI,OAAS,KAAK,QAAQ,IAAI,CAAC,GAAG;AAChD,cAAQ,IAAI,CAAC,IAAI,QAAQ,IAAI,CAAC,EAAE,YAAW;IAC7C;EACF;AAEA,QAAM,SAAS,KAAK,QAAQ,KAAK,EAAE,CAAC;AACpC,uBAAqB,IAAI,GAAG,QAAQ,IAAI,OAAO,IAAI,MAAM;AACzD,SAAO;AACT;AAtDA,IAUM;AAVN;;AAEA;AAIA;AACA;AAGA,IAAM,uBAAqC,oBAAI,OAAgB,IAAI;;;;;ACS7D,SAAU,UACd,SACA,SAAsC;AAEtC,QAAM,EAAE,SAAS,KAAI,IAAK,WAAW,CAAA;AACrC,QAAM,WAAW,GAAG,OAAO,IAAI,MAAM;AAErC,MAAI,eAAe,IAAI,QAAQ;AAAG,WAAO,eAAe,IAAI,QAAQ;AAEpE,QAAM,UAAU,MAAK;AACnB,QAAI,CAAC,aAAa,KAAK,OAAO;AAAG,aAAO;AACxC,QAAI,QAAQ,YAAW,MAAO;AAAS,aAAO;AAC9C,QAAI;AAAQ,aAAO,gBAAgB,OAAkB,MAAM;AAC3D,WAAO;EACT,GAAE;AACF,iBAAe,IAAI,UAAU,MAAM;AACnC,SAAO;AACT;AApCA,IAGM,cAGO;AANb;;;AACA;AAEA,IAAM,eAAe;AAGd,IAAM,iBAA+B,oBAAI,OAAgB,IAAI;;;;;ACI9D,SAAU,OACd,QAAwB;AAExB,MAAI,OAAO,OAAO,CAAC,MAAM;AACvB,WAAO,UAAU,MAAwB;AAC3C,SAAO,YAAY,MAA8B;AACnD;AAIM,SAAU,YAAY,QAA4B;AACtD,MAAI,SAAS;AACb,aAAW,OAAO,QAAQ;AACxB,cAAU,IAAI;EAChB;AACA,QAAM,SAAS,IAAI,WAAW,MAAM;AACpC,MAAI,SAAS;AACb,aAAW,OAAO,QAAQ;AACxB,WAAO,IAAI,KAAK,MAAM;AACtB,cAAU,IAAI;EAChB;AACA,SAAO;AACT;AAIM,SAAU,UAAU,QAAsB;AAC9C,SAAO,KAAM,OAAiB,OAC5B,CAAC,KAAK,MAAM,MAAM,EAAE,QAAQ,MAAM,EAAE,GACpC,EAAE,CACH;AACH;AA/BA;;;;;;ACeM,SAAU,MACd,OACA,OACA,KACA,EAAE,OAAM,IAAuC,CAAA,GAAE;AAEjD,MAAI,MAAM,OAAO,EAAE,QAAQ,MAAK,CAAE;AAChC,WAAO,SAAS,OAAc,OAAO,KAAK;MACxC;KACD;AACH,SAAO,WAAW,OAAoB,OAAO,KAAK;IAChD;GACD;AACH;AAOA,SAAS,kBAAkB,OAAwB,OAA0B;AAC3E,MAAI,OAAO,UAAU,YAAY,QAAQ,KAAK,QAAQ,KAAK,KAAK,IAAI;AAClE,UAAM,IAAI,4BAA4B;MACpC,QAAQ;MACR,UAAU;MACV,MAAM,KAAK,KAAK;KACjB;AACL;AAOA,SAAS,gBACP,OACA,OACA,KAAwB;AAExB,MACE,OAAO,UAAU,YACjB,OAAO,QAAQ,YACf,KAAK,KAAK,MAAM,MAAM,OACtB;AACA,UAAM,IAAI,4BAA4B;MACpC,QAAQ;MACR,UAAU;MACV,MAAM,KAAK,KAAK;KACjB;EACH;AACF;AAcM,SAAU,WACd,QACA,OACA,KACA,EAAE,OAAM,IAAuC,CAAA,GAAE;AAEjD,oBAAkB,QAAQ,KAAK;AAC/B,QAAM,QAAQ,OAAO,MAAM,OAAO,GAAG;AACrC,MAAI;AAAQ,oBAAgB,OAAO,OAAO,GAAG;AAC7C,SAAO;AACT;AAcM,SAAU,SACd,QACA,OACA,KACA,EAAE,OAAM,IAAuC,CAAA,GAAE;AAEjD,oBAAkB,QAAQ,KAAK;AAC/B,QAAM,QAAQ,KAAK,OAChB,QAAQ,MAAM,EAAE,EAChB,OAAO,SAAS,KAAK,IAAI,OAAO,OAAO,UAAU,CAAC,CAAC;AACtD,MAAI;AAAQ,oBAAgB,OAAO,OAAO,GAAG;AAC7C,SAAO;AACT;AA/HA;;;AAOA;AACA;;;;;ACRA,IAIaC,aAIAC;AARb,IAAAC,cAAA;;AAIO,IAAMF,cAAa;AAInB,IAAMC,gBACX;;;;;AC2EI,SAAU,oBAGd,QACA,QAES;AAET,MAAI,OAAO,WAAW,OAAO;AAC3B,UAAM,IAAI,+BAA+B;MACvC,gBAAgB,OAAO;MACvB,aAAa,OAAO;KACrB;AAEH,QAAM,iBAAiB,cAAc;IACnC;IACA;GACD;AACD,QAAM,OAAO,aAAa,cAAc;AACxC,MAAI,KAAK,WAAW;AAAG,WAAO;AAC9B,SAAO;AACT;AAWA,SAAS,cAA4D,EACnE,QACA,OAAM,GAIP;AACC,QAAM,iBAAkC,CAAA;AACxC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,mBAAe,KAAK,aAAa,EAAE,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,CAAC,EAAC,CAAE,CAAC;EAC1E;AACA,SAAO;AACT;AAcA,SAAS,aAA+C,EACtD,OACA,MAAK,GAIN;AACC,QAAM,kBAAkB,mBAAmB,MAAM,IAAI;AACrD,MAAI,iBAAiB;AACnB,UAAM,CAAC,QAAQ,IAAI,IAAI;AACvB,WAAO,YAAY,OAAO,EAAE,QAAQ,OAAO,EAAE,GAAG,OAAO,KAAI,EAAE,CAAE;EACjE;AACA,MAAI,MAAM,SAAS,SAAS;AAC1B,WAAO,YAAY,OAA2B;MAC5C;KACD;EACH;AACA,MAAI,MAAM,SAAS,WAAW;AAC5B,WAAO,cAAc,KAAuB;EAC9C;AACA,MAAI,MAAM,SAAS,QAAQ;AACzB,WAAO,WAAW,KAA2B;EAC/C;AACA,MAAI,MAAM,KAAK,WAAW,MAAM,KAAK,MAAM,KAAK,WAAW,KAAK,GAAG;AACjE,UAAM,SAAS,MAAM,KAAK,WAAW,KAAK;AAC1C,UAAM,CAAC,EAAC,EAAGE,QAAO,KAAK,IAAIC,cAAa,KAAK,MAAM,IAAI,KAAK,CAAA;AAC5D,WAAO,aAAa,OAA4B;MAC9C;MACA,MAAM,OAAOD,KAAI;KAClB;EACH;AACA,MAAI,MAAM,KAAK,WAAW,OAAO,GAAG;AAClC,WAAO,YAAY,OAAyB,EAAE,MAAK,CAAE;EACvD;AACA,MAAI,MAAM,SAAS,UAAU;AAC3B,WAAO,aAAa,KAA0B;EAChD;AACA,QAAM,IAAI,4BAA4B,MAAM,MAAM;IAChD,UAAU;GACX;AACH;AAMA,SAAS,aAAa,gBAA+B;AAEnD,MAAI,aAAa;AACjB,WAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC9C,UAAM,EAAE,SAAS,QAAO,IAAK,eAAe,CAAC;AAC7C,QAAI;AAAS,oBAAc;;AACtB,oBAAc,KAAK,OAAO;EACjC;AAGA,QAAM,eAAsB,CAAA;AAC5B,QAAM,gBAAuB,CAAA;AAC7B,MAAI,cAAc;AAClB,WAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC9C,UAAM,EAAE,SAAS,QAAO,IAAK,eAAe,CAAC;AAC7C,QAAI,SAAS;AACX,mBAAa,KAAK,YAAY,aAAa,aAAa,EAAE,MAAM,GAAE,CAAE,CAAC;AACrE,oBAAc,KAAK,OAAO;AAC1B,qBAAe,KAAK,OAAO;IAC7B,OAAO;AACL,mBAAa,KAAK,OAAO;IAC3B;EACF;AAGA,SAAO,OAAO,CAAC,GAAG,cAAc,GAAG,aAAa,CAAC;AACnD;AASA,SAAS,cAAc,OAAU;AAC/B,MAAI,CAAC,UAAU,KAAK;AAAG,UAAM,IAAI,oBAAoB,EAAE,SAAS,MAAK,CAAE;AACvE,SAAO,EAAE,SAAS,OAAO,SAAS,OAAO,MAAM,YAAW,CAAS,EAAC;AACtE;AAYA,SAAS,YACP,OACA,EACE,QACA,MAAK,GAIN;AAED,QAAM,UAAU,WAAW;AAE3B,MAAI,CAAC,MAAM,QAAQ,KAAK;AAAG,UAAM,IAAI,kBAAkB,KAAK;AAC5D,MAAI,CAAC,WAAW,MAAM,WAAW;AAC/B,UAAM,IAAI,oCAAoC;MAC5C,gBAAgB;MAChB,aAAa,MAAM;MACnB,MAAM,GAAG,MAAM,IAAI,IAAI,MAAM;KAC9B;AAEH,MAAI,eAAe;AACnB,QAAM,iBAAkC,CAAA;AACxC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,gBAAgB,aAAa,EAAE,OAAO,OAAO,MAAM,CAAC,EAAC,CAAE;AAC7D,QAAI,cAAc;AAAS,qBAAe;AAC1C,mBAAe,KAAK,aAAa;EACnC;AAEA,MAAI,WAAW,cAAc;AAC3B,UAAM,OAAO,aAAa,cAAc;AACxC,QAAI,SAAS;AACX,YAAME,UAAS,YAAY,eAAe,QAAQ,EAAE,MAAM,GAAE,CAAE;AAC9D,aAAO;QACL,SAAS;QACT,SAAS,eAAe,SAAS,IAAI,OAAO,CAACA,SAAQ,IAAI,CAAC,IAAIA;;IAElE;AACA,QAAI;AAAc,aAAO,EAAE,SAAS,MAAM,SAAS,KAAI;EACzD;AACA,SAAO;IACL,SAAS;IACT,SAAS,OAAO,eAAe,IAAI,CAAC,EAAE,QAAO,MAAO,OAAO,CAAC;;AAEhE;AAUA,SAAS,YACP,OACA,EAAE,MAAK,GAAoB;AAE3B,QAAM,CAAC,EAAE,SAAS,IAAI,MAAM,KAAK,MAAM,OAAO;AAC9C,QAAM,YAAY,KAAK,KAAK;AAC5B,MAAI,CAAC,WAAW;AACd,QAAI,SAAS;AAGb,QAAI,YAAY,OAAO;AACrB,eAAS,OAAO,QAAQ;QACtB,KAAK;QACL,MAAM,KAAK,MAAM,MAAM,SAAS,KAAK,IAAI,EAAE,IAAI;OAChD;AACH,WAAO;MACL,SAAS;MACT,SAAS,OAAO,CAAC,OAAO,YAAY,WAAW,EAAE,MAAM,GAAE,CAAE,CAAC,GAAG,MAAM,CAAC;;EAE1E;AACA,MAAI,cAAc,OAAO,SAAS,SAAS;AACzC,UAAM,IAAI,kCAAkC;MAC1C,cAAc,OAAO,SAAS,SAAS;MACvC;KACD;AACH,SAAO,EAAE,SAAS,OAAO,SAAS,OAAO,OAAO,EAAE,KAAK,QAAO,CAAE,EAAC;AACnE;AAIA,SAAS,WAAW,OAAc;AAChC,MAAI,OAAO,UAAU;AACnB,UAAM,IAAIC,WACR,2BAA2B,KAAK,YAAY,OAAO,KAAK,qCAAqC;AAEjG,SAAO,EAAE,SAAS,OAAO,SAAS,OAAO,UAAU,KAAK,CAAC,EAAC;AAC5D;AAIA,SAAS,aACP,OACA,EAAE,QAAQ,MAAAH,QAAO,IAAG,GAAkD;AAEtE,MAAI,OAAOA,UAAS,UAAU;AAC5B,UAAM,MAAM,OAAO,OAAOA,KAAI,KAAK,SAAS,KAAK,OAAO;AACxD,UAAM,MAAM,SAAS,CAAC,MAAM,KAAK;AACjC,QAAI,QAAQ,OAAO,QAAQ;AACzB,YAAM,IAAI,uBAAuB;QAC/B,KAAK,IAAI,SAAQ;QACjB,KAAK,IAAI,SAAQ;QACjB;QACA,MAAMA,QAAO;QACb,OAAO,MAAM,SAAQ;OACtB;EACL;AACA,SAAO;IACL,SAAS;IACT,SAAS,YAAY,OAAO;MAC1B,MAAM;MACN;KACD;;AAEL;AAWA,SAAS,aAAa,OAAa;AACjC,QAAM,WAAW,YAAY,KAAK;AAClC,QAAM,cAAc,KAAK,KAAK,KAAK,QAAQ,IAAI,EAAE;AACjD,QAAM,QAAe,CAAA;AACrB,WAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AACpC,UAAM,KACJ,OAAO,MAAM,UAAU,IAAI,KAAK,IAAI,KAAK,EAAE,GAAG;MAC5C,KAAK;KACN,CAAC;EAEN;AACA,SAAO;IACL,SAAS;IACT,SAAS,OAAO;MACd,OAAO,YAAY,KAAK,QAAQ,GAAG,EAAE,MAAM,GAAE,CAAE,CAAC;MAChD,GAAG;KACJ;;AAEL;AASA,SAAS,YAGP,OACA,EAAE,MAAK,GAAoB;AAE3B,MAAI,UAAU;AACd,QAAM,iBAAkC,CAAA;AACxC,WAAS,IAAI,GAAG,IAAI,MAAM,WAAW,QAAQ,KAAK;AAChD,UAAM,SAAS,MAAM,WAAW,CAAC;AACjC,UAAM,QAAQ,MAAM,QAAQ,KAAK,IAAI,IAAI,OAAO;AAChD,UAAM,gBAAgB,aAAa;MACjC,OAAO;MACP,OAAQ,MAAc,KAAM;KAC7B;AACD,mBAAe,KAAK,aAAa;AACjC,QAAI,cAAc;AAAS,gBAAU;EACvC;AACA,SAAO;IACL;IACA,SAAS,UACL,aAAa,cAAc,IAC3B,OAAO,eAAe,IAAI,CAAC,EAAE,QAAO,MAAO,OAAO,CAAC;;AAE3D;AAIM,SAAU,mBACd,MAAY;AAEZ,QAAM,UAAU,KAAK,MAAM,kBAAkB;AAC7C,SAAO;;IAEH,CAAC,QAAQ,CAAC,IAAI,OAAO,QAAQ,CAAC,CAAC,IAAI,MAAM,QAAQ,CAAC,CAAC;MACnD;AACN;AAtaA;;;AAYA;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAQA,IAAAI;;;;;ACnCA,IAAa;AAAb;;AAAO,IAAM,YAAmC,CAAC,OAAO,UAAU,UAChE,KAAK,UACH,OACA,CAAC,KAAK,WAAU;AACd,YAAMC,SAAQ,OAAO,WAAW,WAAW,OAAO,SAAQ,IAAK;AAC/D,aAAO,OAAO,aAAa,aAAa,SAAS,KAAKA,MAAK,IAAIA;IACjE,GACA,KAAK;;;;;ACXT;AAAA;AAAA;AAAA;AAAA;;;ACCA;;;ACCA;AACA;;;ACDA;AACA;AAKM,IAAO,qBAAP,cAAkCC,WAAS;EAC/C,YAAY,EAAE,OAAM,GAAuB;AACzC,UAAM,mBAAmB,UAAU,MAAM,CAAC,MAAM;MAC9C,cAAc,CAAC,iCAAiC;KACjD;EACH;;AAMI,IAAO,0BAAP,cAAuCA,WAAS;EACpD,YAAY,EACV,aACA,MAAK,GAC+D;AACpE,UACE,0BAA0B,WAAW,uBAAuB,KAAK,UAAU,OAAO,KAAK,KAAK,CAAC,CAAC,OAC9F;MACE,UAAU;MACV,cAAc,CAAC,kDAAkD;KAClE;EAEL;;AAMI,IAAO,yBAAP,cAAsCA,WAAS;EACnD,YAAY,EAAE,KAAI,GAAoB;AACpC,UAAM,gBAAgB,IAAI,iBAAiB;MACzC,cAAc,CAAC,0CAA0C;MACzD,MAAM;KACP;EACH;;;;AD/BF;AACA;AACA;AACAC;;;AERA;AAIA;AACA;AACA;AA2BM,SAAU,cAId,YAA2D;AAE3D,QAAM,EACJ,SAAS,CAAA,GACT,SACA,YAAW,IACT;AACJ,QAAM,QAAQ;IACZ,cAAc,wBAAwB,EAAE,OAAM,CAAE;IAChD,GAAG,WAAW;;AAKhB,oBAAkB;IAChB;IACA;IACA;IACA;GACD;AAED,QAAM,QAAe,CAAC,QAAQ;AAC9B,MAAI;AACF,UAAM,KACJ,WAAW;MACT;MACA;KACD,CAAC;AAGN,MAAI,gBAAgB;AAClB,UAAM,KACJ,WAAW;MACT,MAAM;MACN;MACA;KACD,CAAC;AAGN,SAAO,UAAU,OAAO,KAAK,CAAC;AAChC;AAIM,SAAU,WAAW,EACzB,QACA,MAAK,GAIN;AACC,SAAO,WAAW;IAChB,MAAM;IACN,aAAa;IACb;GACD;AACH;AAIM,SAAU,WAAW,EACzB,MACA,aACA,MAAK,GAKN;AACC,QAAM,UAAU,WAAW;IACzB;IACA;IACA;GACD;AACD,SAAO,UAAU,OAAO;AAC1B;AAQA,SAAS,WAAW,EAClB,MACA,aACA,MAAK,GAKN;AACC,QAAM,eAA+B,CAAC,EAAE,MAAM,UAAS,CAAE;AACzD,QAAM,gBAA2B,CAAC,SAAS,EAAE,aAAa,MAAK,CAAE,CAAC;AAElE,aAAW,SAAS,MAAM,WAAW,GAAG;AACtC,UAAM,CAAC,MAAM,KAAK,IAAI,YAAY;MAChC;MACA,MAAM,MAAM;MACZ,MAAM,MAAM;MACZ,OAAO,KAAK,MAAM,IAAI;KACvB;AACD,iBAAa,KAAK,IAAI;AACtB,kBAAc,KAAK,KAAK;EAC1B;AAEA,SAAO,oBAAoB,cAAc,aAAa;AACxD;AAQA,SAAS,SAAS,EAChB,aACA,MAAK,GAIN;AACC,QAAM,kBAAkB,MAAM,WAAW,EAAE,aAAa,MAAK,CAAE,CAAC;AAChE,SAAO,UAAU,eAAe;AAClC;AAIM,SAAU,WAAW,EACzB,aACA,MAAK,GAIN;AACC,MAAI,SAAS;AACb,QAAM,eAAe,qBAAqB,EAAE,aAAa,MAAK,CAAE;AAChE,eAAa,OAAO,WAAW;AAE/B,QAAM,OAAO,CAAC,aAAa,GAAG,MAAM,KAAK,YAAY,EAAE,KAAI,CAAE;AAC7D,aAAW,QAAQ,MAAM;AACvB,cAAU,GAAG,IAAI,IAAI,MAAM,IAAI,EAC5B,IAAI,CAAC,EAAE,MAAM,MAAM,EAAC,MAAO,GAAG,CAAC,IAAI,IAAI,EAAE,EACzC,KAAK,GAAG,CAAC;EACd;AAEA,SAAO;AACT;AAIA,SAAS,qBACP,EACE,aAAa,cACb,MAAK,GAKP,UAAuB,oBAAI,IAAG,GAAE;AAEhC,QAAM,QAAQ,aAAa,MAAM,OAAO;AACxC,QAAM,cAAc,QAAQ,CAAC;AAC7B,MAAI,QAAQ,IAAI,WAAW,KAAK,MAAM,WAAW,MAAM,QAAW;AAChE,WAAO;EACT;AAEA,UAAQ,IAAI,WAAW;AAEvB,aAAW,SAAS,MAAM,WAAW,GAAG;AACtC,yBAAqB,EAAE,aAAa,MAAM,MAAM,MAAK,GAAI,OAAO;EAClE;AACA,SAAO;AACT;AAQA,SAAS,YAAY,EACnB,OACA,MACA,MACA,MAAK,GAMN;AACC,MAAI,MAAM,IAAI,MAAM,QAAW;AAC7B,WAAO;MACL,EAAE,MAAM,UAAS;MACjB,UAAU,WAAW,EAAE,MAAM,OAAO,aAAa,MAAM,MAAK,CAAE,CAAC;;EAEnE;AAEA,MAAI,SAAS,SAAS;AACpB,UAAM,UAAU,MAAM,SAAS,IAAI,MAAM;AACzC,YAAQ,KAAK,UAAU,MAAM,MAAM,CAAC,CAAC;AACrC,WAAO,CAAC,EAAE,MAAM,UAAS,GAAI,UAAU,KAAK,CAAC;EAC/C;AAEA,MAAI,SAAS;AAAU,WAAO,CAAC,EAAE,MAAM,UAAS,GAAI,UAAU,MAAM,KAAK,CAAC,CAAC;AAE3E,MAAI,KAAK,YAAY,GAAG,MAAM,KAAK,SAAS,GAAG;AAC7C,UAAM,aAAa,KAAK,MAAM,GAAG,KAAK,YAAY,GAAG,CAAC;AACtD,UAAM,iBAAkB,MAAgC,IAAI,CAAC,SAC3D,YAAY;MACV;MACA,MAAM;MACN;MACA,OAAO;KACR,CAAC;AAEJ,WAAO;MACL,EAAE,MAAM,UAAS;MACjB,UACE,oBACE,eAAe,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,GAC7B,eAAe,IAAI,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CACjC;;EAGP;AAEA,SAAO,CAAC,EAAE,KAAI,GAAI,KAAK;AACzB;;;AFxMM,SAAU,kBAGd,YAAuD;AACvD,QAAM,EAAE,QAAQ,SAAS,aAAa,MAAK,IACzC;AAEF,QAAM,eAAe,CACnB,QACA,SACE;AACF,eAAW,SAAS,QAAQ;AAC1B,YAAM,EAAE,MAAM,KAAI,IAAK;AACvB,YAAM,QAAQ,KAAK,IAAI;AAEvB,YAAM,eAAe,KAAK,MAAMC,aAAY;AAC5C,UACE,iBACC,OAAO,UAAU,YAAY,OAAO,UAAU,WAC/C;AACA,cAAM,CAAC,OAAO,MAAM,KAAK,IAAI;AAG7B,oBAAY,OAAO;UACjB,QAAQ,SAAS;UACjB,MAAM,OAAO,SAAS,KAAK,IAAI;SAChC;MACH;AAEA,UAAI,SAAS,aAAa,OAAO,UAAU,YAAY,CAAC,UAAU,KAAK;AACrE,cAAM,IAAI,oBAAoB,EAAE,SAAS,MAAK,CAAE;AAElD,YAAM,aAAa,KAAK,MAAMC,WAAU;AACxC,UAAI,YAAY;AACd,cAAM,CAAC,OAAO,KAAK,IAAI;AACvB,YAAI,SAAS,KAAK,KAAY,MAAM,OAAO,SAAS,KAAK;AACvD,gBAAM,IAAI,uBAAuB;YAC/B,cAAc,OAAO,SAAS,KAAK;YACnC,WAAW,KAAK,KAAY;WAC7B;MACL;AAEA,YAAMC,UAAS,MAAM,IAAI;AACzB,UAAIA,SAAQ;AACV,0BAAkB,IAAI;AACtB,qBAAaA,SAAQ,KAAgC;MACvD;IACF;EACF;AAGA,MAAI,MAAM,gBAAgB,QAAQ;AAChC,QAAI,OAAO,WAAW;AAAU,YAAM,IAAI,mBAAmB,EAAE,OAAM,CAAE;AACvE,iBAAa,MAAM,cAAc,MAAM;EACzC;AAGA,MAAI,gBAAgB,gBAAgB;AAClC,QAAI,MAAM,WAAW;AAAG,mBAAa,MAAM,WAAW,GAAG,OAAO;;AAC3D,YAAM,IAAI,wBAAwB,EAAE,aAAa,MAAK,CAAE;EAC/D;AACF;AAIM,SAAU,wBAAwB,EACtC,OAAM,GACmC;AACzC,SAAO;IACL,OAAO,QAAQ,SAAS,YAAY,EAAE,MAAM,QAAQ,MAAM,SAAQ;IAClE,QAAQ,WAAW,EAAE,MAAM,WAAW,MAAM,SAAQ;IACpD,OAAO,QAAQ,YAAY,YAAY;MACrC,MAAM;MACN,MAAM;;IAER,QAAQ,qBAAqB;MAC3B,MAAM;MACN,MAAM;;IAER,QAAQ,QAAQ,EAAE,MAAM,QAAQ,MAAM,UAAS;IAC/C,OAAO,OAAO;AAClB;AAiBA,SAAS,kBAAkB,MAAY;AAErC,MACE,SAAS,aACT,SAAS,UACT,SAAS,YACT,KAAK,WAAW,OAAO,KACvB,KAAK,WAAW,MAAM,KACtB,KAAK,WAAW,KAAK;AAErB,UAAM,IAAI,uBAAuB,EAAE,KAAI,CAAE;AAC7C;;;AGpLA;;;ACFO,IAAM,uBAAuB;;;ACGpC;AACA;AACA;AAaM,SAAU,kBAAkB,UAAyB;AACzD,QAAM,WAAW,MAAK;AACpB,QAAI,OAAO,aAAa;AAAU,aAAO,YAAY,QAAQ;AAC7D,QAAI,OAAO,SAAS,QAAQ;AAAU,aAAO,SAAS;AACtD,WAAO,WAAW,SAAS,GAAG;EAChC,GAAE;AACF,QAAM,SAAS,YAAY,GAAG,oBAAoB,GAAG,KAAK,OAAO,CAAC,EAAE;AACpE,SAAO,OAAO,CAAC,QAAQ,OAAO,CAAC;AACjC;;;AFbM,SAAU,YACd,SACA,KAAoB;AAEpB,SAAO,UAAU,kBAAkB,OAAO,GAAG,GAAG;AAClD;;;AJsoCA;AAyOA;AAyHA;;;ADv/CO,IAAM,uBAAN,MAAqD;AAAA,EAO1D,YAAY,cAA4B;AANxC,SAAS,OAAO;AAOd,SAAK,SAAS;AAEd,UAAM,EAAE,QAAQ,IAAI,KAAK,OAAO;AAEhC,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,YAAY,SAAc,kBAA4B,gBAA0B,UAAiC;AACrH,UAAM,MAAM,QAAQ,YAAY,EAAC,KAAK,QAAQ,OAAO,EAAC,CAAC,CAAC;AACxD,UAAM,YAAiB,MAAM,KAAK,OAAO,YAAY;AAAA,MACnD,SAAS,EAAC,KAAK,IAAG;AAAA,MAClB,SAAS,KAAK,OAAO;AAAA,IACvB,CAAC;AACD,QAAI,aAAa,MAAM;AACrB,YAAM,iBAAiB;AAAA,QACrB,mBAAmB,uBAAuB;AAAA,QAC1C,CAAC,gBAAgB,UAAU,OAAO,CAAC,kBAAkB,SAAS,CAAC,CAAC;AAAA,MAClE;AACA,aAAO,iBAAiB;AAAA,IAC1B;AACA,WAAO,OAAO;AAAA,MACZ;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,MAAM,cAAc,KAAqB,kBAA4B,gBAA0B,UAAiC;AAC9H,UAAM,mBAAmB,cAAc,EAAC,QAAQ,IAAI,QAAQ,OAAO,IAAI,OAAO,aAAa,IAAI,aAAa,SAAS,IAAI,QAAO,CAAC;AACjI,UAAM,YAAY,MAAM,KAAK,OAAO,YAAY;AAAA,MAC9C,SAAS,EAAC,KAAK,QAAQ,gBAAgB,EAAC;AAAA,MACxC,SAAS,KAAK,OAAO;AAAA,IACvB,CAAC;AACD,QAAI,aAAa,MAAM;AACrB,YAAM,iBAAiB;AAAA,QACrB,mBAAmB,uBAAuB;AAAA,QAC1C,CAAC,gBAAgB,UAAU,OAAO,CAAC,kBAAkB,SAAS,CAAC,CAAC;AAAA,MAClE;AACA,aAAO,iBAAiB;AAAA,IAC1B;AACA,WAAO;AAAA,MAAO;AAAA,QACZ;AAAA,QACA;AAAA,MAAS;AAAA,IACX;AAAA,EACF;AAAA,EAEA,MAAM,oBAAoB,SAAoC;AAC5D,WAAO,CAAC,OAAO;AAAA,EACjB;AAAA,EAEA,MAAM,aAAa,SAAoC;AACrD,WAAO,CAAC,OAAO;AAAA,EACjB;AAAA,EAEA,MAAM,WAAW,SAA+B;AAC9C,WAAO,KAAK,OAAO,YAAY;AAAA,MAC7B,SAAS,EAAE,KAAK,QAAQ;AAAA,MACxB,SAAS,KAAK,OAAO;AAAA,IACvB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,oBAAoB,aAAgD;AACxE,WAAO,KAAK,OAAO,gBAAgB;AAAA,MACjC,GAAG;AAAA,MACH,SAAS,KAAK,OAAO;AAAA,MACrB,OAAO,KAAK,OAAO;AAAA,MACnB,KAAK;AAAA,IACP,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,oBAAoB,aAAkD;AAC1E,WAAO,KAAK,OAAO,gBAAgB;AAAA,MACjC,GAAG;AAAA,MACH,SAAS,KAAK,OAAO;AAAA,MACrB,OAAO,KAAK,OAAO;AAAA,MACnB,KAAK;AAAA,IACP,CAAC;AAAA,EACH;AACF;","names":["length","version","init_version","BaseError","init_version","version","BaseError","BaseError","size","size","BaseError","size","size","size","BaseError","encoder","toBytes","init_utils","init_utils","toBytes","BaseError","size","bytesRegex","integerRegex","init_regex","size","integerRegex","length","BaseError","init_regex","value","BaseError","init_regex","integerRegex","bytesRegex","struct"]}