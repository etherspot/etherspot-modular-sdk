{"version":3,"sources":["../../src/sdk/base/calcPreVerificationGas.ts"],"sourcesContent":["\nimport { NotPromise, packUserOp } from '../common/index.js';\nimport { Buffer } from 'buffer';\nimport { toBytes, toHex } from 'viem';\nimport { BaseAccountUserOperationStruct } from '../types/user-operation-types.js';\n\nexport interface GasOverheads {\n  /**\n   * fixed overhead for entire handleOp bundle.\n   */\n  fixed: number;\n\n  /**\n   * per userOp overhead, added on top of the above fixed per-bundle.\n   */\n  perUserOp: number;\n\n  /**\n   * overhead for userOp word (32 bytes) block\n   */\n  perUserOpWord: number;\n\n  // perCallDataWord: number\n\n  /**\n   * zero byte cost, for calldata gas cost calculations\n   */\n  zeroByte: number;\n\n  /**\n   * non-zero byte cost, for calldata gas cost calculations\n   */\n  nonZeroByte: number;\n\n  /**\n   * expected bundle size, to split per-bundle overhead between all ops.\n   */\n  bundleSize: number;\n\n  /**\n   * expected length of the userOp signature.\n   */\n  sigSize: number;\n}\n\nexport const DefaultGasOverheads: GasOverheads = {\n  fixed: 21000,\n  perUserOp: 18300,\n  perUserOpWord: 4,\n  zeroByte: 4,\n  nonZeroByte: 16,\n  bundleSize: 1,\n  sigSize: 65,\n};\n\n/**\n * calculate the preVerificationGas of the given UserOperation\n * preVerificationGas (by definition) is the cost overhead that can't be calculated on-chain.\n * it is based on parameters that are defined by the Ethereum protocol for external transactions.\n * @param userOp filled userOp to calculate. The only possible missing fields can be the signature and preVerificationGas itself\n * @param overheads gas overheads to use, to override the default values\n */\nexport function calcPreVerificationGas(\n  userOp: Partial<BaseAccountUserOperationStruct>,\n  overheads?: Partial<GasOverheads>,\n): number {\n  const ov = { ...DefaultGasOverheads, ...(overheads ?? {}) };\n  const p: NotPromise<BaseAccountUserOperationStruct> = {\n    // dummy values, in case the UserOp is incomplete.\n    preVerificationGas: 21000, // dummy value, just for calldata cost\n    signature: toHex(Buffer.alloc(ov.sigSize, 1)), // dummy signature\n    ...userOp,\n  } as any;\n\n  const packed = toBytes(packUserOp(p, false));\n  const callDataCost = packed.map((x) => (x === 0 ? ov.zeroByte : ov.nonZeroByte)).reduce((sum, x) => sum + x);\n  const ret = Math.round(callDataCost + ov.fixed / ov.bundleSize + ov.perUserOp + ov.perUserOpWord * packed.length);\n  return ret;\n}\n"],"mappings":";;;;;;;;;AAEA,SAAS,cAAc;AA2ChB,IAAM,sBAAoC;AAAA,EAC/C,OAAO;AAAA,EACP,WAAW;AAAA,EACX,eAAe;AAAA,EACf,UAAU;AAAA,EACV,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,SAAS;AACX;AASO,SAAS,uBACd,QACA,WACQ;AACR,QAAM,KAAK,EAAE,GAAG,qBAAqB,GAAI,aAAa,CAAC,EAAG;AAC1D,QAAM,IAAgD;AAAA;AAAA,IAEpD,oBAAoB;AAAA;AAAA,IACpB,WAAW,MAAM,OAAO,MAAM,GAAG,SAAS,CAAC,CAAC;AAAA;AAAA,IAC5C,GAAG;AAAA,EACL;AAEA,QAAM,SAAS,QAAQ,WAAW,GAAG,KAAK,CAAC;AAC3C,QAAM,eAAe,OAAO,IAAI,CAAC,MAAO,MAAM,IAAI,GAAG,WAAW,GAAG,WAAY,EAAE,OAAO,CAAC,KAAK,MAAM,MAAM,CAAC;AAC3G,QAAM,MAAM,KAAK,MAAM,eAAe,GAAG,QAAQ,GAAG,aAAa,GAAG,YAAY,GAAG,gBAAgB,OAAO,MAAM;AAChH,SAAO;AACT;","names":[]}