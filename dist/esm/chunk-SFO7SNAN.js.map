{"version":3,"sources":["../../src/sdk/wallet/providers/wallet-connect-2.wallet-provider.ts"],"sourcesContent":["import { Address, concat, encodeAbiParameters, Hash, hashMessage, Hex, parseAbiParameters, toBytes, toHex, TransactionRequest } from 'viem';\nimport { DynamicWalletProvider } from './dynamic.wallet-provider.js';\nimport { EthereumProvider } from './interfaces.js';\n\nexport class WalletConnect2WalletProvider extends DynamicWalletProvider {\n  constructor(readonly provider: EthereumProvider) {\n    super('WalletConnect2');\n\n    try {\n      const {\n        accounts: [address],\n        chainId,\n      } = provider;\n\n      this.setAddress(address);\n      this.setNetworkName(chainId);\n    } catch (err) {\n      //\n    }\n\n    this.updateSessionHandler = this.updateSessionHandler.bind(this);\n\n    provider.on('connect', this.updateSessionHandler);\n    provider.on('session_event', this.updateSessionHandler);\n    provider.on('disconnect', () => {\n      this.setAddress(null);\n      this.setNetworkName(null);\n    });\n  }\n\n  async signMessage(message: Hex, validatorAddress?: Address, factoryAddress?: Address, initCode?: Hex): Promise<string> {\n    const msg = toBytes(hashMessage({raw: toBytes(message)}))\n    const response: Hex = await this.provider.signer.request({\n      method: 'personal_sign',\n      params: [msg, this.address],\n    });\n    if (initCode !== '0x') {\n      const abiCoderResult = encodeAbiParameters(\n        parseAbiParameters('address, bytes, bytes'),\n        [factoryAddress, initCode, concat([validatorAddress, response])]\n      )\n      return abiCoderResult + '6492649264926492649264926492649264926492649264926492649264926492'; //magicBytes\n    }\n    return typeof response === 'string' ? validatorAddress + response.slice(2) : null;\n  }\n\n  async signUserOp(message: Hex): Promise<string> {\n    return this.provider.signer.request({\n      method: 'personal_sign',\n      params: [toHex(message), this.address],\n    })\n  }\n\n  async signTypedData(typedData: any, validatorAddress?: Address, factoryAddress?: Address, initCode?: Hex): Promise<string> {\n    const signature: Hex = await this.provider.signer.request({\n      method: 'eth_signTypedData_v4',\n      params: [\n        this.address,\n        typedData\n      ]\n    })\n    if (initCode !== '0x') {\n      const abiCoderResult = encodeAbiParameters(\n        parseAbiParameters('address, bytes, bytes'),\n        [factoryAddress, initCode, concat([validatorAddress, signature])]\n      )\n      return abiCoderResult + '6492649264926492649264926492649264926492649264926492649264926492'; //magicBytes\n    }\n    return typeof signature === 'string' ? validatorAddress + signature.slice(2) : null;\n  }\n\n  async eth_requestAccounts(address: string): Promise<string[]> {\n    return [address];\n  }\n\n  async eth_accounts(address: string): Promise<string[]> {\n    return [address];\n  }\n\n  async eth_sendTransaction(transaction: TransactionRequest): Promise<Hash> {\n    return this.provider.signer.request({method: 'eth_sendTransaction', params: [\n      transaction\n    ]});\n  }\n\n  async eth_signTransaction(transaction: TransactionRequest): Promise<string> {\n    return this.provider.signer.request({method: 'eth_signTransaction', params: [\n      transaction\n    ]});\n  }\n\n  protected updateSessionHandler(error: Error, payload: { params: { accounts: string[]; chainId: number } }): void {\n    let address: string = null;\n    let chainId: number = null;\n\n    if (!error) {\n      try {\n        ({\n          accounts: [address],\n          chainId,\n        } = payload.params[0]);\n      } catch (err) {\n        address = null;\n        chainId = null;\n      }\n    }\n\n    this.setAddress(address);\n    this.setNetworkName(chainId);\n  }\n}\n"],"mappings":"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","names":[]}