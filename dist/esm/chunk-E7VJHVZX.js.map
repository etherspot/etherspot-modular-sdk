{"version":3,"sources":["../../src/sdk/base/EtherspotWalletAPI.ts","../../src/sdk/sdk.ts","../../src/sdk/index.ts","../../src/sdk/base/BaseAccountAPI.ts"],"sourcesContent":["import { BaseApiParams, BaseAccountAPI } from './BaseAccountAPI.js';\nimport { BootstrapConfig, _makeBootstrapConfig, makeBootstrapConfig } from './Bootstrap.js';\nimport { DEFAULT_BOOTSTRAP_ADDRESS, Networks, DEFAULT_QUERY_PAGE_SIZE } from '../network/constants.js';\nimport { CALL_TYPE, EXEC_TYPE, MODULE_TYPE, getExecuteMode } from '../common/index.js';\nimport { encodeFunctionData, parseAbi, encodeAbiParameters, parseAbiParameters, concat, getAddress, pad, toHex, isBytes, Hex, isAddress } from 'viem';\nimport { accountAbi, bootstrapAbi, entryPointAbi, factoryAbi } from '../common/abis.js';\nimport { getInstalledModules } from '../common/getInstalledModules.js';\nimport { getViemAddress } from '../common/utils/viem-utils.js';\nimport { BigNumber, BigNumberish } from '../types/bignumber.js';\n\n// Creating a constant for the sentinel address using viem\nconst SENTINEL_ADDRESS = getAddress(\"0x0000000000000000000000000000000000000001\");\nconst ADDRESS_ZERO = getAddress(\"0x0000000000000000000000000000000000000000\");\n\n/**\n * constructor params, added no top of base params:\n * @param owner the signer object for the account owner\n * @param factoryAddress address of contract \"factory\" to deploy new contracts (not needed if account already deployed)\n * @param index nonce value used when creating multiple accounts for the same owner\n */\nexport interface EtherspotWalletApiParams extends BaseApiParams {\n  factoryAddress?: string;\n  index?: number;\n  predefinedAccountAddress?: string;\n}\n\nexport type ModuleInfo = {\n  validators?: string[];\n  executors?: string[];\n  hook?: string;\n  fallbacks?: FallbackInfo[];\n};\n\nexport type FallbackInfo = {\n  selector: string;\n  handlerAddress: string;\n};\n\n/**\n * An implementation of the BaseAccountAPI using the EtherspotWallet contract.\n * - contract deployer gets \"entrypoint\", \"owner\" addresses and \"index\" nonce\n * - owner signs requests using normal \"Ethereum Signed Message\" (ether's signer.signMessage())\n * - nonce method is \"nonce()\"\n * - execute method is \"execFromEntryPoint()\"\n */\nexport class EtherspotWalletAPI extends BaseAccountAPI {\n  index: number;\n  predefinedAccountAddress?: string;\n  bootstrapAddress?: string;\n  eoaAddress: Hex;\n\n  constructor(params: EtherspotWalletApiParams) {\n    super(params);\n    this.index = params.index ?? 0;\n    this.predefinedAccountAddress = params.predefinedAccountAddress ?? null;\n    this.bootstrapAddress = Networks[params.optionsLike.chainId]?.contracts?.bootstrap ?? DEFAULT_BOOTSTRAP_ADDRESS;\n  }\n\n  public getEOAAddress(): Hex {\n    return this.services.walletService.EOAAddress;\n  }\n\n  async isModuleInstalled(moduleTypeId: MODULE_TYPE, module: string, initData = '0x'): Promise<boolean> {\n    const accountAddress = await this.getAccountAddress();\n    if (!accountAddress) throw new Error('Account address not found');\n    const response = await this.publicClient.readContract({\n      address: accountAddress as Hex,\n      abi: parseAbi(accountAbi),\n      functionName: 'isModuleInstalled',\n      args: [moduleTypeId, module, initData]\n    });\n    return response as boolean;\n  }\n\n  async installModule(moduleTypeId: MODULE_TYPE, module: string, initData = '0x'): Promise<string> {\n    const accountAddress = await this.getAccountAddress();\n    if (!accountAddress) throw new Error('Account address not found');\n\n    if (await this.isModuleInstalled(moduleTypeId, module, initData)) {\n      throw new Error('the module is already installed');\n    }\n    return encodeFunctionData({\n      functionName: 'installModule',\n      abi: parseAbi(accountAbi),\n      args: [moduleTypeId, module, initData],\n    });\n  }\n\n  async uninstallModule(moduleTypeId: MODULE_TYPE, module: string, deinitData: string): Promise<string> {\n    const isModuleInstalled = await this.isModuleInstalled(moduleTypeId, module, deinitData);\n    if (!isModuleInstalled) {\n      throw new Error('he module is not installed in the wallet');\n    }\n\n    // if this is uninstall on validator or executor, we need to check if there is more than 1 module\n    // we cant delete all modules when moduletypeid is validator or executor\n    if (moduleTypeId === MODULE_TYPE.EXECUTOR || moduleTypeId === MODULE_TYPE.VALIDATOR) {\n      const installedModules = moduleTypeId === MODULE_TYPE.EXECUTOR ? await this.getAllExecutors() : await this.getAllValidators();\n      if (installedModules.length === 1) {\n        throw new Error('Cannot uninstall the only module');\n      }\n    }\n\n    return encodeFunctionData({\n      functionName: 'uninstallModule',\n      abi: parseAbi(accountAbi),\n      args: [moduleTypeId, module, deinitData],\n    });\n  }\n\n  async getAllExecutors(pageSize: number = DEFAULT_QUERY_PAGE_SIZE): Promise<string[]> {\n    return await getInstalledModules({ client: this.publicClient, moduleAddress: getViemAddress(this.accountAddress), moduleTypes: ['executor'], pageSize: pageSize });\n  }\n\n  async getPreviousAddress(targetAddress: string, moduleTypeId: MODULE_TYPE): Promise<string> {\n\n    if (moduleTypeId !== MODULE_TYPE.EXECUTOR && moduleTypeId !== MODULE_TYPE.VALIDATOR) {\n      throw new Error(\"Unsupported module type\");\n    }\n\n    const insalledModules = moduleTypeId === MODULE_TYPE.EXECUTOR ? await this.getAllExecutors() : await this.getAllValidators()\n\n    const index = insalledModules.indexOf(targetAddress)\n    if (index === 0) {\n      return SENTINEL_ADDRESS\n    } else if (index > 0) {\n      return insalledModules[index - 1]\n    } else {\n      throw new Error(`Module ${targetAddress} not found in installed modules`)\n    }\n  }\n\n  // here its users responsibility to prepare deInit Data\n  // deinitData is prepared as bytes data made of the previous node address and the deinit data\n  // the deinit data is the data that is passed to the module to be uninstalled\n  async generateModuleDeInitData(moduleTypeId: MODULE_TYPE, module: string, deinitDataBase: string): Promise<string> {\n\n    // this is applicable only for Executor and Validator modules\n    // if the module type is not Executor or Validator, throw an error\n    if (moduleTypeId !== MODULE_TYPE.EXECUTOR && moduleTypeId !== MODULE_TYPE.VALIDATOR) {\n      throw new Error(\"Unsupported module type\");\n    }\n\n    // Get the previous address in the list\n    const previousAddress = await this.getPreviousAddress(module, moduleTypeId);\n\n    // Prepare the deinit data\n    const deInitDataGenerated = encodeAbiParameters(\n      parseAbiParameters('address, bytes'),\n      [previousAddress as Hex, deinitDataBase as Hex]\n    )\n\n    return deInitDataGenerated;\n  }\n\n  // function to get validators\n  async getAllValidators(pageSize: number = DEFAULT_QUERY_PAGE_SIZE): Promise<string[]> {\n    return await getInstalledModules({ client: this.publicClient, moduleAddress: getViemAddress(this.accountAddress), moduleTypes: ['validator'], pageSize: pageSize });\n  }\n\n  // function to get active hook\n  async getActiveHook(): Promise<string> {\n    const activeHook = await this.publicClient.readContract({\n      address: this.accountAddress as Hex,\n      abi: parseAbi(accountAbi),\n      functionName: 'getActiveHook',\n    });\n\n    return activeHook as Hex;\n  }\n\n  async getFallbacks(): Promise<any[]> {\n    return [];\n  }\n\n  // function to club the response of getAllExecutors, getAllValidators and getActiveHook\n  // return should be a wrapper of tis way\n  // prepare a schema like above and return the response\n  async getAllModules(pageSize: number = DEFAULT_QUERY_PAGE_SIZE): Promise<ModuleInfo> {\n    const validators = await this.getAllValidators(pageSize) || [];\n    const executors = await this.getAllExecutors(pageSize) || [];\n    const hook = await this.getActiveHook() || \"\";\n    const fallbacks = await this.getFallbacks() || [];\n\n    return {\n      validators,\n      executors,\n      hook,\n      fallbacks\n    };\n  }\n\n\n  async checkAccountAddress(address: string): Promise<void> {\n    const eoaAddress = await this.getEOAAddress();\n    const isOwner = await this.publicClient.readContract({\n      address: address as Hex,\n      abi: parseAbi(accountAbi),\n      functionName: 'isOwner',\n      args: [eoaAddress]\n    }) as boolean;\n    if (!isOwner) {\n      throw new Error('the specified accountAddress does not belong to the given EOA provider')\n    } else {\n      this.accountAddress = address;\n    }\n  }\n\n  async getInitCodeData(): Promise<string> {\n    const validators: BootstrapConfig[] = makeBootstrapConfig(this.validatorAddress, '0x');\n    const executors: BootstrapConfig[] = makeBootstrapConfig(ADDRESS_ZERO, '0x');\n    const hook: BootstrapConfig = _makeBootstrapConfig(ADDRESS_ZERO, '0x');\n    const fallbacks: BootstrapConfig[] = makeBootstrapConfig(ADDRESS_ZERO, '0x');\n\n    const initMSAData = encodeFunctionData({\n      functionName: 'initMSA',\n      abi: parseAbi(bootstrapAbi),\n      args: [validators, executors, hook, fallbacks],\n    });\n    const eoaAddress = await this.getEOAAddress();\n\n    const initCode = encodeAbiParameters(\n      parseAbiParameters('address, address, bytes'),\n      [eoaAddress, this.bootstrapAddress as Hex, initMSAData]\n    )\n\n    return initCode;\n  }\n\n  /**\n   * return the value to put into the \"initCode\" field, if the account is not yet deployed.\n   * this value holds the \"factory\" address, followed by this account's information\n   */\n  async getAccountInitCode(): Promise<string> {\n    if (this.factoryAddress == null || this.factoryAddress == '') {\n      throw new Error('no factory to get initCode');\n    }\n\n    const initCode = await this.getInitCodeData();\n    const salt = pad(toHex(this.index), { size: 32 });\n\n    const functionData = encodeFunctionData({\n      functionName: 'createAccount',\n      abi: parseAbi(factoryAbi),\n      args: [\n        salt,\n        initCode,\n      ],\n    })\n\n    return concat([\n      this.factoryAddress as Hex,\n      functionData,\n    ]);\n  }\n\n  async getCounterFactualAddress(): Promise<string> {\n    if (this.predefinedAccountAddress) {\n      await this.checkAccountAddress(this.predefinedAccountAddress);\n    }\n\n    const salt = pad(toHex(this.index), { size: 32 });\n    const initCode = await this.getInitCodeData();\n\n    if (!this.accountAddress) {\n      this.accountAddress = (await this.publicClient.readContract({\n        address: this.factoryAddress as Hex,\n        abi: parseAbi(factoryAbi),\n        functionName: 'getAddress',\n        args: [salt, initCode]\n      })) as Hex;\n    }\n    return this.accountAddress;\n  }\n\n  async getNonce(key: BigNumber = BigNumber.from(0)): Promise<BigNumber> {\n    const accountAddress = await this.getAccountAddress();\n\n    const nonceKey = key.eq(0) ? this.validatorAddress : key.toHexString();\n\n    if (!this.checkAccountPhantom()) {\n\n      let isAddressIndicator = false;\n\n      try {\n        isAddressIndicator = isAddress(getAddress(nonceKey), { strict: true });\n        if (!isAddressIndicator) {\n          throw new Error(`Invalid Validator Address: ${nonceKey}`);\n        }\n        else {\n          const isModuleInstalled = await this.isModuleInstalled(MODULE_TYPE.VALIDATOR, nonceKey);\n          if (!isModuleInstalled) {\n            throw new Error(`Validator: ${nonceKey} is not installed in the wallet`);\n          }\n        }\n\n      } catch (e) {\n        console.error(`Error caught : ${e}`);\n        throw new Error(`Invalid Validator Address: ${nonceKey}`);\n      }\n    }\n\n    const dummyKey = getAddress(nonceKey) + \"00000000\"\n\n    const nonceResponse = await this.publicClient.readContract({\n      address: this.entryPointAddress as Hex,\n      abi: parseAbi(entryPointAbi),\n      functionName: 'getNonce',\n      args: [accountAddress, BigInt(dummyKey)]\n    });\n    return nonceResponse as BigNumber;\n  }\n\n  /**\n   * encode a method call from entryPoint to our contract\n   * @param target\n   * @param value\n   * @param data\n   */\n  async encodeExecute(target: string, value: BigNumberish, data: string): Promise<string> {\n    const executeMode = getExecuteMode({\n      callType: CALL_TYPE.SINGLE,\n      execType: EXEC_TYPE.DEFAULT\n    });\n\n    // Assuming toHex is a function that accepts string | number | bigint | boolean | Uint8Array\n    // Convert BigNumberish to a string if it's a BigNumber\n    // Convert BigNumberish or Bytes to a compatible type\n    let valueToProcess: string | number | bigint | boolean | Uint8Array;\n\n    if (BigNumber.isBigNumber(value)) {\n      valueToProcess = value.toString(); // Convert BigNumber to string\n    } else if (isBytes(value)) {\n      valueToProcess = new Uint8Array(value); // Convert Bytes to Uint8Array\n    } else {\n      // Here, TypeScript is unsure about the type of `value`\n      // You need to ensure `value` is of a type compatible with `valueToProcess`\n      // If `value` can only be string, number, bigint, boolean, or Uint8Array, this assignment is safe\n      // If `value` can be of other types (like Bytes), you need an explicit conversion or handling here\n      // For example, if there's a chance `value` is still `Bytes`, you could handle it like so:\n      if (typeof value === 'object' && value !== null && 'length' in value) {\n        // Assuming this condition is sufficient to identify Bytes-like objects\n        // Convert it to Uint8Array\n        valueToProcess = new Uint8Array(Object.values(value));\n      } else {\n        valueToProcess = value as string | number | bigint | boolean | Uint8Array;\n      }\n    }\n\n    const calldata = concat([\n      target as Hex,\n      pad(toHex(valueToProcess), { size: 32 }) as Hex,\n      data as Hex\n    ]);\n\n    return encodeFunctionData({\n      functionName: 'execute',\n      abi: parseAbi(accountAbi),\n      args: [executeMode, calldata],\n    });\n  }\n\n  async signUserOpHash(userOpHash: string): Promise<string> {\n    return await this.services.walletService.signUserOp(userOpHash as Hex);\n  }\n\n  async encodeBatch(targets: string[], values: BigNumberish[], datas: string[]): Promise<string> {\n\n    const executeMode = getExecuteMode({\n      callType: CALL_TYPE.BATCH,\n      execType: EXEC_TYPE.DEFAULT\n    });\n\n    const result = targets.map((target, index) => ({\n      target: target as Hex,\n      value: values[index],\n      callData: datas[index] as Hex\n    }));\n\n    const convertedResult = result.map(item => ({\n      ...item,\n      // Convert `value` from BigNumberish to bigint\n      value: typeof item.value === 'bigint' ? item.value : BigInt(item.value.toString()),\n    }));\n\n    //TODO-Test-LibraryFix identify the syntax for viem to pass array of tuple\n    // const calldata = ethers.utils.defaultAbiCoder.encode(\n    //   [\"tuple(address target,uint256 value,bytes callData)[]\"],\n    //   [result]\n    // );\n\n    const calldata = encodeAbiParameters(\n      parseAbiParameters('(address target,uint256 value,bytes callData)[]'),\n      [convertedResult]\n    )\n\n    return encodeFunctionData({\n      functionName: 'execute',\n      abi: parseAbi(accountAbi),\n      args: [executeMode, calldata],\n    });\n  }\n}\n","import { Factory, PaymasterApi, SdkOptions } from './interfaces.js';\nimport { Network } from \"./network/index.js\";\nimport {\n  BatchUserOpsRequest, Exception, getGasFee,\n  getViemAddress, MODULE_TYPE,\n  UserOperation, UserOpsRequest\n} from \"./common/index.js\";\nimport {\n  EthereumProvider,\n  isWalletConnectProvider,\n  isWalletProvider,\n  MessagePayload,\n  WalletConnect2WalletProvider,\n  WalletProviderLike\n} from './wallet/index.js';\nimport { DEFAULT_QUERY_PAGE_SIZE, Networks } from './network/constants.js';\nimport { EtherspotWalletAPI, HttpRpcClient, VerifyingPaymasterAPI } from './base/index.js';\nimport { TransactionDetailsForUserOp, TransactionGasInfoForUserOp } from './base/TransactionDetailsForUserOp.js';\nimport { SignMessageDto, validateDto } from './dto/index.js';\nimport { ErrorHandler } from './errorHandler/errorHandler.service.js';\nimport { EtherspotBundler } from './bundler/index.js';\nimport { ModuleInfo } from './base/EtherspotWalletAPI.js';\nimport { Account, formatEther, Hex, http, type PublicClient } from 'viem';\nimport { getPublicClient } from './common/utils/viem-utils.js';\nimport { BigNumber, BigNumberish } from './types/bignumber.js';\n\n/**\n * Modular-Sdk\n *\n * @category Modular-Sdk\n */\nexport class ModularSdk {\n\n  private etherspotWallet: EtherspotWalletAPI;\n  private bundler: HttpRpcClient;\n  private chainId: number;\n  private factoryUsed: Factory;\n  private index: number;\n  private publicClient: PublicClient;\n  private account: Account;\n  private providerUrl: string;\n\n  private userOpsBatch: BatchUserOpsRequest = { to: [], data: [], value: [] };\n\n  constructor(walletProvider: WalletProviderLike, optionsLike: SdkOptions) {\n    let walletConnectProvider;\n    if (isWalletConnectProvider(walletProvider)) {\n      walletConnectProvider = new WalletConnect2WalletProvider(walletProvider as EthereumProvider);\n    } else if (!isWalletProvider(walletProvider)) {\n      throw new Exception('Invalid wallet provider');\n    }\n\n    const {\n      index,\n      chainId,\n      rpcProviderUrl,\n      accountAddress,\n    } = optionsLike;\n\n    this.chainId = chainId;\n    this.index = index ?? 0;\n\n    if (!optionsLike.bundlerProvider) {\n      optionsLike.bundlerProvider = new EtherspotBundler(chainId);\n    }\n\n    this.factoryUsed = optionsLike.factoryWallet ?? Factory.ETHERSPOT;\n    let viemClientUrl = '';\n\n    if (rpcProviderUrl) {\n      viemClientUrl = rpcProviderUrl;\n    } else {\n      viemClientUrl = optionsLike.bundlerProvider.url;\n    }\n\n    this.providerUrl = viemClientUrl;\n\n    this.publicClient = getPublicClient({\n      chainId: chainId,\n      transport: http(\n        viemClientUrl\n      )\n    }) as PublicClient;\n\n    let entryPointAddress = '', walletFactoryAddress = '';\n    if (Networks[chainId]) {\n      entryPointAddress = Networks[chainId].contracts.entryPoint;\n      if (Networks[chainId].contracts.walletFactory == '') throw new Exception('The selected factory is not deployed in the selected chain_id')\n      walletFactoryAddress = Networks[chainId].contracts.walletFactory;\n    }\n\n    if (optionsLike.entryPointAddress) entryPointAddress = optionsLike.entryPointAddress;\n    if (optionsLike.walletFactoryAddress) walletFactoryAddress = optionsLike.walletFactoryAddress;\n\n    if (entryPointAddress == '') throw new Exception('entryPointAddress not set on the given chain_id')\n    if (walletFactoryAddress == '') throw new Exception('walletFactoryAddress not set on the given chain_id')\n    this.account = this.account;\n    this.etherspotWallet = new EtherspotWalletAPI({\n      optionsLike,\n      entryPointAddress,\n      factoryAddress: walletFactoryAddress,\n      predefinedAccountAddress: accountAddress,\n      index: this.index,\n      wallet: walletConnectProvider ?? walletProvider,\n      publicClient: this.publicClient,\n    });\n    this.bundler = new HttpRpcClient(\n      optionsLike.bundlerProvider.url,\n      entryPointAddress,\n      chainId,\n      this.publicClient\n    );\n  }\n\n  get supportedNetworks(): Network[] {\n    return this.etherspotWallet.services.networkService.supportedNetworks;\n  }\n\n  /**\n   * destroys\n   */\n  destroy(): void {\n    this.etherspotWallet.context.destroy();\n  }\n\n  getPublicClient(): PublicClient {\n    return this.publicClient;\n  }\n\n  getProviderUrl(): string {\n    return this.providerUrl;\n  }\n\n  // wallet\n\n  /**\n   * signs message\n   * @param dto\n   * @return Promise<string>\n   */\n  async signMessage(dto: SignMessageDto): Promise<string> {\n    await validateDto(dto, SignMessageDto);\n\n    await this.etherspotWallet.require({\n      network: false,\n    });\n\n    return await this.etherspotWallet.signMessage(dto);\n  }\n\n  getEOAAddress(): Hex {\n    return this.etherspotWallet.getEOAAddress();\n  }\n\n  async getCounterFactualAddress(): Promise<string> {\n    return this.etherspotWallet.getCounterFactualAddress();\n  }\n\n  async estimate(params: {\n    paymasterDetails?: PaymasterApi,\n    gasDetails?: TransactionGasInfoForUserOp,\n    callGasLimit?: BigNumberish,\n    key?: BigNumber\n  } = {}) {\n    const { paymasterDetails, gasDetails, callGasLimit, key } = params;\n    const dummySignature = \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n    if (this.userOpsBatch.to.length < 1) {\n      throw new ErrorHandler('cannot sign empty transaction batch', 1);\n    }\n\n    if (paymasterDetails?.url) {\n      const paymasterAPI = new VerifyingPaymasterAPI(paymasterDetails.url, this.etherspotWallet.entryPointAddress, paymasterDetails.context ?? {})\n      this.etherspotWallet.setPaymasterApi(paymasterAPI)\n    } else this.etherspotWallet.setPaymasterApi(null);\n\n    const tx: TransactionDetailsForUserOp = {\n      target: this.userOpsBatch.to,\n      values: this.userOpsBatch.value,\n      data: this.userOpsBatch.data,\n      dummySignature: dummySignature,\n      ...gasDetails,\n    }\n\n    const gasInfo = await this.getGasFee();\n\n    const partialtx = await this.etherspotWallet.createUnsignedUserOp({\n      ...tx,\n      maxFeePerGas: gasInfo.maxFeePerGas,\n      maxPriorityFeePerGas: gasInfo.maxPriorityFeePerGas,\n    }, key);\n\n    if (callGasLimit) {\n      partialtx.callGasLimit = BigNumber.from(callGasLimit).toHexString();\n    }\n\n    if (await this.etherspotWallet.checkAccountPhantom()) {\n      partialtx.factory = this.etherspotWallet.factoryAddress;\n    }\n\n    const bundlerGasEstimate = await this.bundler.getVerificationGasInfo(partialtx);\n\n    // if user has specified the gas prices then use them\n    if (gasDetails?.maxFeePerGas && gasDetails?.maxPriorityFeePerGas) {\n      partialtx.maxFeePerGas = gasDetails.maxFeePerGas;\n      partialtx.maxPriorityFeePerGas = gasDetails.maxPriorityFeePerGas;\n    }\n    // if estimation has gas prices use them, otherwise fetch them in a separate call\n    else if (bundlerGasEstimate.maxFeePerGas && bundlerGasEstimate.maxPriorityFeePerGas) {\n      partialtx.maxFeePerGas = bundlerGasEstimate.maxFeePerGas;\n      partialtx.maxPriorityFeePerGas = bundlerGasEstimate.maxPriorityFeePerGas;\n    } else {\n      const gas = await this.getGasFee();\n      partialtx.maxFeePerGas = gas.maxFeePerGas;\n      partialtx.maxPriorityFeePerGas = gas.maxPriorityFeePerGas;\n    }\n\n    if (bundlerGasEstimate.preVerificationGas) {\n      partialtx.preVerificationGas = BigNumber.from(bundlerGasEstimate.preVerificationGas);\n      partialtx.verificationGasLimit = BigNumber.from(bundlerGasEstimate.verificationGasLimit ?? bundlerGasEstimate.verificationGas);\n      const expectedCallGasLimit = BigNumber.from(bundlerGasEstimate.callGasLimit);\n      if (!callGasLimit)\n        partialtx.callGasLimit = expectedCallGasLimit;\n      else if (BigNumber.from(callGasLimit).lt(expectedCallGasLimit))\n        throw new ErrorHandler(`CallGasLimit is too low. Expected atleast ${expectedCallGasLimit.toString()}`);\n    }\n\n    return partialtx;\n\n  }\n\n  async getGasFee() {\n    const version = await this.bundler.getBundlerVersion();\n    if (version && version.includes('skandha'))\n      return this.bundler.getSkandhaGasPrice();\n    return getGasFee(this.publicClient);\n  }\n\n  async send(userOp: any, isUserOpAlreadySigned = false) {\n    const signedUserOp = isUserOpAlreadySigned ? userOp : await this.etherspotWallet.signUserOp(userOp);\n    return this.bundler.sendUserOpToBundler(signedUserOp);\n  }\n\n  async signTypedData(\n    msg: MessagePayload\n  ) {\n    return this.etherspotWallet.signTypedData(msg);\n  }\n\n  async getNativeBalance() {\n    if (!this.etherspotWallet.accountAddress) {\n      await this.getCounterFactualAddress();\n    }\n    const balance = await this.publicClient.getBalance({ address: getViemAddress(this.etherspotWallet.accountAddress) });\n    return formatEther(balance);\n  }\n\n  async getUserOpReceipt(userOpHash: string) {\n    //return this.bundler.getUserOpsReceipt(userOpHash);\n    return await this.etherspotWallet.getUserOpReceipt(userOpHash);\n  }\n\n  async getUserOpHash(userOp: UserOperation) {\n    return this.etherspotWallet.getUserOpHash(userOp);\n  }\n\n  async addUserOpsToBatch(\n    tx: UserOpsRequest,\n  ): Promise<BatchUserOpsRequest> {\n    if (!tx.data && !tx.value) throw new ErrorHandler('Data and Value both cannot be empty', 1);\n    this.userOpsBatch.to.push(tx.to);\n    this.userOpsBatch.value.push(tx.value ?? BigNumber.from(0));\n    this.userOpsBatch.data.push(tx.data ?? '0x');\n    return this.userOpsBatch;\n  }\n\n  async clearUserOpsFromBatch(): Promise<void> {\n    this.userOpsBatch.to = [];\n    this.userOpsBatch.data = [];\n    this.userOpsBatch.value = [];\n  }\n\n  async isModuleInstalled(moduleTypeId: MODULE_TYPE, module: string): Promise<boolean> {\n    return this.etherspotWallet.isModuleInstalled(moduleTypeId, module);\n  }\n\n  async installModule(moduleTypeId: MODULE_TYPE, module: string, initData?: string): Promise<string> {\n    const installData = await this.etherspotWallet.installModule(moduleTypeId, module, initData);\n\n    this.clearUserOpsFromBatch();\n\n    await this.addUserOpsToBatch({\n      to: this.etherspotWallet.accountAddress ?? await this.getCounterFactualAddress(),\n      data: installData\n    });\n\n    const op = await this.estimate();\n    const uoHash = await this.send(op);\n    return uoHash;\n  }\n\n  async getPreviousModuleAddress(moduleTypeId: MODULE_TYPE, module: string): Promise<string> {\n    return this.etherspotWallet.getPreviousAddress(module, moduleTypeId);\n  }\n\n  async generateModuleDeInitData(moduleTypeId: MODULE_TYPE, module: string, moduleDeInitData: string): Promise<string> {\n    return await this.etherspotWallet.generateModuleDeInitData(moduleTypeId, module, moduleDeInitData);\n  }\n\n  async getPreviousAddress(moduleTypeId: MODULE_TYPE, targetAddress: string): Promise<string> {\n    return await this.etherspotWallet.getPreviousAddress(targetAddress, moduleTypeId);\n  }\n\n  async uninstallModule(moduleTypeId: MODULE_TYPE, module: string, deinitData: string): Promise<string> {\n    const uninstallData = await this.etherspotWallet.uninstallModule(moduleTypeId, module, deinitData);\n\n    this.clearUserOpsFromBatch();\n\n    await this.addUserOpsToBatch({\n      to: this.etherspotWallet.accountAddress ?? await this.getCounterFactualAddress(),\n      data: uninstallData\n    });\n\n    const op = await this.estimate();\n    const uoHash = await this.send(op);\n    return uoHash;\n  }\n\n  async getAllModules(pageSize: number = DEFAULT_QUERY_PAGE_SIZE): Promise<ModuleInfo> {\n    const modules = await this.etherspotWallet.getAllModules(pageSize);\n    return modules;\n  }\n\n  async totalGasEstimated(userOp: UserOperation): Promise<BigNumber> {\n    const callGasLimit = BigNumber.from(await userOp.callGasLimit);\n    const verificationGasLimit = BigNumber.from(await userOp.verificationGasLimit);\n    const preVerificationGas = BigNumber.from(await userOp.preVerificationGas);\n    return callGasLimit.add(verificationGasLimit).add(preVerificationGas);\n  }\n\n  async getNonce(key: BigNumber = BigNumber.from(0)): Promise<BigNumber> {\n    const nonce = await this.etherspotWallet.getNonce(key);\n    return nonce;\n  }\n}\n","import { SessionKeyValidator } from './SessionKeyValidator/index.js';\nimport { ModularSdk } from './sdk.js';\n\nexport * from './dto/index.js';\nexport * from './interfaces.js';\nexport * from './network/index.js';\nexport * from './bundler/index.js';\nexport * from './common/index.js';\n\nexport { ModularSdk, SessionKeyValidator };\nexport default ModularSdk;","import { TransactionDetailsForUserOp } from './TransactionDetailsForUserOp.js';\nimport { PaymasterAPI } from './PaymasterAPI.js';\nimport { ErrorSubject, Exception, getUserOpHash, NotPromise, packUserOp, UserOperation } from '../common/index.js';\nimport { calcPreVerificationGas, GasOverheads } from './calcPreVerificationGas.js';\nimport { Factory, Network, NetworkNames, NetworkService, SdkOptions, SignMessageDto, validateDto } from '../index.js';\nimport { Context } from '../context.js';\nimport { PaymasterResponse } from './VerifyingPaymasterAPI.js';\nimport { Hex, parseAbi, PublicClient } from 'viem';\nimport { entryPointAbi } from '../common/abis.js';\nimport { resolveProperties } from '../common/utils/index.js';\nimport { BaseAccountUserOperationStruct, FeeData } from '../types/user-operation-types.js';\nimport { BigNumber, BigNumberish } from '../types/bignumber.js';\nimport { MessagePayload, WalletProviderLike, WalletService } from '../wallet/index.js';\nimport { DEFAULT_MULTIPLE_OWNER_ECDSA_VALIDATOR_ADDRESS, Networks } from '../network/index.js';\n\nexport interface BaseApiParams {\n  entryPointAddress: string;\n  accountAddress?: string;\n  overheads?: Partial<GasOverheads>;\n  factoryAddress?: string;\n  optionsLike?: SdkOptions;\n  publicClient?: PublicClient;\n  wallet: WalletProviderLike;\n}\n\nexport interface UserOpResult {\n  transactionHash: string;\n  success: boolean;\n}\n\n/**\n * Base class for all Smart Wallet ERC-4337 Clients to implement.\n * Subclass should inherit 5 methods to support a specific wallet contract:\n *\n * - getAccountInitCode - return the value to put into the \"initCode\" field, if the account is not yet deployed. should create the account instance using a factory contract.\n * - getNonce - return current account's nonce value\n * - encodeExecute - encode the call from entryPoint through our account to the target contract.\n * - signUserOpHash - sign the hash of a UserOp.\n *\n * The user can use the following APIs:\n * - createUnsignedUserOp - given \"target\" and \"calldata\", fill userOp to perform that operation from the account.\n * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it\n */\nexport abstract class BaseAccountAPI {\n  private senderAddress!: string;\n  private isPhantom = true;\n\n  readonly services: Context['services'];\n\n  context: Context;\n\n  overheads?: Partial<GasOverheads>;\n  entryPointAddress: string;\n  accountAddress?: string;\n  paymasterAPI?: PaymasterAPI;\n  factoryUsed: Factory;\n  factoryAddress?: string;\n  validatorAddress?: string;\n  wallet: WalletProviderLike;\n  publicClient: PublicClient;\n\n  /**\n   * base constructor.\n   * subclass SHOULD add parameters that define the owner (signer) of this wallet\n   */\n  constructor(params: BaseApiParams) {\n\n    const optionsLike = params.optionsLike;\n\n    const {\n      chainId, //\n      rpcProviderUrl,\n      factoryWallet,\n      bundlerProvider,\n    } = optionsLike;\n\n    this.services = {\n      networkService: new NetworkService(chainId),\n      walletService: new WalletService(\n        params.wallet,\n        { provider: rpcProviderUrl},\n        bundlerProvider.url,\n        chainId\n      ),\n    };\n\n    this.context = new Context(this.services);\n\n    this.factoryUsed = factoryWallet;\n\n    // super();\n    this.overheads = params.overheads;\n    this.entryPointAddress = params.entryPointAddress;\n    this.accountAddress = params.accountAddress;\n    this.factoryAddress = params.factoryAddress;\n    this.publicClient = params.publicClient;\n    this.validatorAddress = Networks[params.optionsLike.chainId]?.contracts?.multipleOwnerECDSAValidator ?? DEFAULT_MULTIPLE_OWNER_ECDSA_VALIDATOR_ADDRESS;\n  }\n\n  get error$(): ErrorSubject {\n    return this.context.error$;\n  }\n\n  get supportedNetworks(): Network[] {\n    return this.services.networkService.supportedNetworks;\n  }\n\n  // sdk\n\n  /**\n   * destroys\n   */\n  destroy(): void {\n    this.context.destroy();\n  }\n\n  // wallet\n\n  /**\n   * signs message\n   * @param dto\n   * @return Promise<string>\n   */\n  async signMessage(dto: SignMessageDto): Promise<string> {\n    const { message } = await validateDto(dto, SignMessageDto);\n\n    await this.require({\n      network: false,\n    });\n\n    const initCode = await this.getInitCode();\n    return this.services.walletService.signMessage(message as Hex, `0x${this.validatorAddress.slice(2)}`, `0x${this.factoryAddress.slice(2)}`, `0x${initCode.substring(42)}`);\n  }\n\n  async setPaymasterApi(paymaster: PaymasterAPI | null) {\n    this.paymasterAPI = paymaster;\n  }\n\n\n  // private\n\n\n  async require(\n    options: {\n      network?: boolean;\n      wallet?: boolean;\n    } = {},\n  ): Promise<void> {\n    options = {\n      network: true,\n      wallet: true,\n      ...options,\n    };\n  }\n\n  getNetworkChainId(networkName: NetworkNames = null): number {\n    let result: number;\n\n    if (!networkName) {\n      ({ chainId: result } = this.services.networkService);\n    } else {\n      const network = this.supportedNetworks.find(({ name }) => name === networkName);\n\n      if (!network) {\n        throw new Exception('Unsupported network');\n      }\n\n      ({ chainId: result } = network);\n    }\n\n    return result;\n  }\n\n  async validateResolveName(\n    options: {\n      network?: number;\n      name?: string;\n    } = {},\n  ): Promise<void> {\n    options = {\n      ...options,\n    };\n\n    const { networkService } = this.services;\n\n    if (options.network && !networkService.chainId) {\n      throw new Exception('Unknown network');\n    }\n\n    if (!options.name) {\n      throw new Exception('Require name');\n    }\n  }\n\n  async init(): Promise<this> {\n    // check EntryPoint is deployed at given address\n    if ((await this.publicClient.getCode({ address: this.entryPointAddress as Hex })) === '0x') {\n      throw new Error(`entryPoint not deployed at ${this.entryPointAddress}`);\n    }\n\n    await this.getAccountAddress();\n    return this;\n  }\n\n  /**\n   * return the value to put into the \"initCode\" field, if the contract is not yet deployed.\n   * this value holds the \"factory\" address, followed by this account's information\n   */\n  protected abstract getAccountInitCode(): Promise<string>;\n\n  /**\n   * return current account's nonce.\n   */\n  protected abstract getNonce(key?: BigNumber): Promise<BigNumber>;\n\n  /**\n   * encode the call from entryPoint through our account to the target contract.\n   * @param target\n   * @param value\n   * @param data\n   */\n  protected abstract encodeExecute(target: string, value: BigNumberish, data: string): Promise<string>;\n\n  protected abstract encodeBatch(targets: string[], values: BigNumberish[], datas: string[]): Promise<string>;\n\n  /**\n   * sign a userOp's hash (userOpHash).\n   * @param userOpHash\n   */\n  protected abstract signUserOpHash(userOpHash: string): Promise<string>;\n\n  /**\n   * check if the contract is already deployed.\n   */\n  async checkAccountPhantom(): Promise<boolean> {\n    if (!this.isPhantom) {\n      // already deployed. no need to check anymore.\n      return this.isPhantom;\n    }\n    const accountAddress = await this.getAccountAddress();\n    const senderAddressCode = await this.publicClient.getCode({ address: accountAddress as Hex })\n    if (senderAddressCode && senderAddressCode.length > 2) {\n      this.isPhantom = false;\n    }\n    return this.isPhantom;\n  }\n\n  /**\n   * calculate the account address even before it is deployed\n   */\n  async getCounterFactualAddress(): Promise<string> {\n    const initCode = await this.getAccountInitCode();\n    // use entryPoint to query account address (factory can provide a helper method to do the same, but\n    // this method attempts to be generic\n    try {\n      //await this.entryPointView.callStatic.getSenderAddress(initCode);\n      await this.publicClient.simulateContract({\n        address: this.entryPointAddress as Hex,\n        abi: parseAbi(entryPointAbi),\n        functionName: 'getSenderAddress',\n        args: [initCode]\n      });\n\n\n    } catch (e: any) {\n      return e.errorArgs.sender;\n    }\n    throw new Error('must handle revert');\n  }\n\n  /**\n   * return initCode value to into the UserOp.\n   * (either deployment code, or empty hex if contract already deployed)\n   */\n  async getInitCode(): Promise<string> {\n    if (await this.checkAccountPhantom()) {\n      return await this.getAccountInitCode();\n    }\n    return '0x';\n  }\n\n  /**\n   * return maximum gas used for verification.\n   * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.\n   */\n  async getVerificationGasLimit(): Promise<BigNumberish> {\n    return 100000;\n  }\n\n  /**\n   * should cover cost of putting calldata on-chain, and some overhead.\n   * actual overhead depends on the expected bundle size\n   */\n  async getPreVerificationGas(userOp: Partial<BaseAccountUserOperationStruct>): Promise<number> {\n    const p = await resolveProperties(userOp);\n    return calcPreVerificationGas(p, this.overheads);\n  }\n\n  /**\n   * ABI-encode a user operation. used for calldata cost estimation\n   */\n  packUserOp(userOp: NotPromise<BaseAccountUserOperationStruct>): string {\n    return packUserOp(userOp, false);\n  }\n\n  async encodeUserOpCallDataAndGasLimit(\n    detailsForUserOp: TransactionDetailsForUserOp,\n  ): Promise<{ callData: string; callGasLimit: BigNumber }> {\n    function parseNumber(a: any): BigNumber | null {\n      if (a == null || a === '') return null;\n      return BigNumber.from(a.toString());\n    }\n\n    const value = parseNumber(detailsForUserOp.value) ?? BigNumber.from(0);\n    let callData: string;\n    const data = detailsForUserOp.data;\n    let target = detailsForUserOp.target;\n    if (typeof data === 'string') {\n      if (typeof target !== 'string') {\n        throw new Error('must have target address if data is single value');\n      }\n      callData = await this.encodeExecute(target, value, data);\n    } else {\n      if (typeof target === 'string') {\n        target = Array(data.length).fill(target);\n      }\n      callData = await this.encodeBatch(target, detailsForUserOp.values, data);\n    }\n\n    const callGasLimit =\n      parseNumber(detailsForUserOp.gasLimit) ?? BigNumber.from(35000)\n\n    return {\n      callData,\n      callGasLimit,\n    };\n  }\n\n  /**\n   * return userOpHash for signing.\n   * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)\n   * @param userOp userOperation, (signature field ignored)\n   */\n  async getUserOpHash(userOp: UserOperation): Promise<string> {\n    const op = await resolveProperties(userOp);\n    const chainId = await this.publicClient.getChainId();\n    return getUserOpHash(op, this.entryPointAddress, chainId);\n  }\n\n  /**\n   * return the account's address.\n   * this value is valid even before deploying the contract.\n   */\n  async getAccountAddress(): Promise<string> {\n    if (this.senderAddress == null) {\n      if (this.accountAddress != null) {\n        this.senderAddress = this.accountAddress;\n      } else {\n        this.senderAddress = await this.getCounterFactualAddress();\n      }\n    }\n    return this.senderAddress;\n  }\n\n  async estimateCreationGas(initCode?: string): Promise<BigNumberish> {\n    if (initCode == null || initCode === '0x') return 0;\n    const deployerAddress = initCode.substring(0, 42);\n    const deployerCallData = '0x' + initCode.substring(42);\n    const estimatedGas = await this.publicClient.estimateGas({\n      to: deployerAddress,\n      data: deployerCallData,\n    });\n\n    return estimatedGas ? estimatedGas : 0;\n  }\n\n  async getFeeData(): Promise<FeeData> {\n\n    const maxFeePerGasResponse = await this.publicClient.estimateFeesPerGas();\n    const maxPriorityFeePerGasResponse = await this.publicClient.estimateMaxPriorityFeePerGas();\n\n    const maxFeePerGas = maxFeePerGasResponse ? BigNumber.from(maxFeePerGasResponse.maxFeePerGas) : null;\n    const maxPriorityFeePerGas = maxPriorityFeePerGasResponse ? BigNumber.from(maxPriorityFeePerGasResponse.toString()) : null;\n\n    return { maxFeePerGas, maxPriorityFeePerGas};\n  }\n\n  /**\n   * create a UserOperation, filling all details (except signature)\n   * - if account is not yet created, add initCode to deploy it.\n   * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the account is created)\n   * @param info\n   */\n  async createUnsignedUserOp(info: TransactionDetailsForUserOp, key = BigNumber.from(0)): Promise<any> {\n    const { callData, callGasLimit } = await this.encodeUserOpCallDataAndGasLimit(info);\n    const factoryData = await this.getInitCode();\n\n    const initGas = await this.estimateCreationGas(factoryData);\n    const verificationGasLimit = BigNumber.from(await this.getVerificationGasLimit()).add(initGas);\n\n    let { maxFeePerGas, maxPriorityFeePerGas } = info;\n    if (maxFeePerGas == null || maxPriorityFeePerGas == null) {\n      let feeData: any = {};\n      try {\n        feeData = await this.getFeeData();\n      } catch (err) {\n        console.warn(\n          \"getGas: eth_maxPriorityFeePerGas failed, falling back to legacy gas price.\"\n        );\n        const gas = await this.publicClient.getGasPrice();\n\n        feeData = { maxFeePerGas: gas, maxPriorityFeePerGas: gas };\n      }\n      if (maxFeePerGas == null) {\n        maxFeePerGas = feeData.maxFeePerGas ?? undefined;\n      }\n      if (maxPriorityFeePerGas == null) {\n        maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? undefined;\n      }\n    }\n    let partialUserOp: any;\n    if (factoryData !== '0x') {\n      partialUserOp = {\n        sender: await this.getAccountAddress(),\n        nonce: await this.getNonce(key),\n        factory: this.factoryAddress,\n        factoryData: '0x' + factoryData.substring(42),\n        callData,\n        callGasLimit,\n        verificationGasLimit,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n      };\n    } else {\n      partialUserOp = {\n        sender: await this.getAccountAddress(),\n        nonce: await this.getNonce(key),\n        factoryData: '0x' + factoryData.substring(42),\n        callData,\n        callGasLimit,\n        verificationGasLimit,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n      };\n    }\n\n\n    let paymasterData: PaymasterResponse | undefined = null;\n    if (this.paymasterAPI != null) {\n      // fill (partial) preVerificationGas (all except the cost of the generated paymasterData)\n      const userOpForPm = {\n        ...partialUserOp,\n        preVerificationGas: this.getPreVerificationGas(partialUserOp),\n      };\n      paymasterData = (await this.paymasterAPI.getPaymasterData(userOpForPm));\n      partialUserOp.verificationGasLimit = paymasterData.result.verificationGasLimit;\n      partialUserOp.preVerificationGas = paymasterData.result.preVerificationGas;\n      partialUserOp.callGasLimit = paymasterData.result.callGasLimit;\n      partialUserOp.paymaster = paymasterData.result.paymaster;\n      partialUserOp.paymasterVerificationGasLimit = paymasterData.result.paymasterVerificationGasLimit;\n      partialUserOp.paymasterPostOpGasLimit = paymasterData.result.paymasterPostOpGasLimit;\n    }\n    partialUserOp.paymasterData = paymasterData ? paymasterData.result.paymasterData : '0x';\n    return {\n      ...partialUserOp,\n      preVerificationGas: this.getPreVerificationGas(partialUserOp),\n      signature: info.dummySignature ?? '0x',\n    };\n  }\n\n  /**\n   * Sign the filled userOp.\n   * @param userOp the UserOperation to sign (with signature field ignored)\n   */\n  async signUserOp(userOp: UserOperation): Promise<UserOperation> {\n    if (this.paymasterAPI != null) {\n      const paymasterData = await this.paymasterAPI.getPaymasterData(userOp);\n      userOp.verificationGasLimit = paymasterData.result.verificationGasLimit;\n      userOp.preVerificationGas = paymasterData.result.preVerificationGas;\n      userOp.callGasLimit = paymasterData.result.callGasLimit;\n      userOp.paymaster = paymasterData.result.paymaster;\n      userOp.paymasterVerificationGasLimit = paymasterData.result.paymasterVerificationGasLimit;\n      userOp.paymasterPostOpGasLimit = paymasterData.result.paymasterPostOpGasLimit;\n    }\n    const userOpHash = await this.getUserOpHash(userOp);\n    const signature = await this.signUserOpHash(userOpHash);\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n\n  /**\n   * helper method: create and sign a user operation.\n   * @param info transaction details for the userOp\n   */\n  async createSignedUserOp(info: TransactionDetailsForUserOp, key = BigNumber.from(0)): Promise<UserOperation> {\n    return await this.signUserOp(await this.createUnsignedUserOp(info, key));\n  }\n\n  /**\n   * get the transaction that has this userOpHash mined, or null if not found\n   * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)\n   * @param timeout stop waiting after this timeout\n   * @param interval time to wait between polls.\n   * @return the transactionHash this userOp was mined, or null if not found.\n   */\n  async getUserOpReceipt(userOpHash: string, timeout = 30000, interval = 5000): Promise<string | null> {\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n      const response = await this.publicClient.request({\n        method: 'eth_getUserOperationReceipt',\n        params: [\n          userOpHash\n        ]\n      }) as any;\n      if (response && response.receipt !== undefined) {\n        return response.receipt.transactionHash;\n      }\n      await new Promise((resolve) => setTimeout(resolve, interval));\n    }\n\n    return null;\n  }\n\n  async signTypedData(msg: MessagePayload) {\n    const initCode = await this.getInitCode();\n    return await this.services.walletService.signTypedData(\n      msg,\n      `0x${this.validatorAddress.slice(2)}`,\n      `0x${this.factoryAddress.slice(2)}`,\n      `0x${initCode.substring(42)}`\n    )\n  }\n}\n"],"mappings":"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","names":[]}