{"version":3,"sources":["../../src/sdk/common/utils/hashing-utils.ts"],"sourcesContent":["import { encodePacked, Hex } from \"viem\";\nimport { isAddress } from \"./viem-utils.js\";\nimport { BytesLike } from \"../types.js\";\nimport { isHex as isAHex, stringToBytes} from 'viem';\n\nexport function keccak256(data: BytesLike): string {\n    let result: string = null;\n  \n    if (data) {\n      switch (typeof data) {\n        case 'string':\n          if (isAddress(data)) {\n            result = keccak256(encodePacked(['address'], [data as Hex]))  \n          } else if (isHex(data)) {\n            result = keccak256(encodePacked(['bytes'], [data as Hex]));\n          } else {\n            result = keccak256(encodePacked(['string'], [data as Hex]));\n          }\n          break;\n        case 'object': {\n          //result = utils.solidityKeccak256(['bytes'], [data]);\n          // TODO-LibraryFix - this needs debugging as its migrated from ethers\n          result = keccak256(encodePacked(['bytes'], [data.toString() as Hex]));\n          break;\n        }\n      }\n    }\n  \n    return result;\n  }\n  \n  export function isHex(hex: string, size = 0): boolean {\n    let result = isAHex(hex);\n  \n    if (result && size > 0) {\n      result = hex.length === size * 2 + 2;\n    }\n  \n    return result;\n  }\n  \n  export function toHexFromBytesLike(data: BytesLike): string {\n    let result: string = null;\n  \n    if (data !== null) {\n      switch (typeof data) {\n        case 'string':\n          if (isHex(data)) {\n            result = data;\n          } else {\n            result = toHexFromBytesLike(stringToBytes(data));\n          }\n          break;\n  \n        case 'object':\n          try {\n            result = toHexFromBytesLike(data as any);\n          } catch (err) {\n            result = null;\n          }\n          break;\n      }\n    }\n  \n    if (!result) {\n      throw new Error('invalid hex data');\n    }\n  \n    return result;\n  }\n  \n  export function concatHex(...hex: string[]): string {\n    return hex.map((item, index) => (index ? item.slice(2) : item)).join('');\n  }\n  "],"mappings":";;;;;;;;;;;;AAKO,SAAS,UAAU,MAAyB;AAC/C,MAAI,SAAiB;AAErB,MAAI,MAAM;AACR,YAAQ,OAAO,MAAM;AAAA,MACnB,KAAK;AACH,YAAI,UAAU,IAAI,GAAG;AACnB,mBAAS,UAAU,aAAa,CAAC,SAAS,GAAG,CAAC,IAAW,CAAC,CAAC;AAAA,QAC7D,WAAWA,OAAM,IAAI,GAAG;AACtB,mBAAS,UAAU,aAAa,CAAC,OAAO,GAAG,CAAC,IAAW,CAAC,CAAC;AAAA,QAC3D,OAAO;AACL,mBAAS,UAAU,aAAa,CAAC,QAAQ,GAAG,CAAC,IAAW,CAAC,CAAC;AAAA,QAC5D;AACA;AAAA,MACF,KAAK,UAAU;AAGb,iBAAS,UAAU,aAAa,CAAC,OAAO,GAAG,CAAC,KAAK,SAAS,CAAQ,CAAC,CAAC;AACpE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAASA,OAAM,KAAa,OAAO,GAAY;AACpD,MAAI,SAAS,MAAO,GAAG;AAEvB,MAAI,UAAU,OAAO,GAAG;AACtB,aAAS,IAAI,WAAW,OAAO,IAAI;AAAA,EACrC;AAEA,SAAO;AACT;AAEO,SAAS,mBAAmB,MAAyB;AAC1D,MAAI,SAAiB;AAErB,MAAI,SAAS,MAAM;AACjB,YAAQ,OAAO,MAAM;AAAA,MACnB,KAAK;AACH,YAAIA,OAAM,IAAI,GAAG;AACf,mBAAS;AAAA,QACX,OAAO;AACL,mBAAS,mBAAmB,cAAc,IAAI,CAAC;AAAA,QACjD;AACA;AAAA,MAEF,KAAK;AACH,YAAI;AACF,mBAAS,mBAAmB,IAAW;AAAA,QACzC,SAAS,KAAK;AACZ,mBAAS;AAAA,QACX;AACA;AAAA,IACJ;AAAA,EACF;AAEA,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AAEA,SAAO;AACT;AAEO,SAAS,aAAa,KAAuB;AAClD,SAAO,IAAI,IAAI,CAAC,MAAM,UAAW,QAAQ,KAAK,MAAM,CAAC,IAAI,IAAK,EAAE,KAAK,EAAE;AACzE;","names":["isHex"]}